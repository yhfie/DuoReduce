number,code_snippet_01,code_snippet_02,code_snippet_03,code_snippet_04,code_snippet_05,code_snippet_06,code_snippet_07,code_snippet_08,code_snippet_09,code_snippet_10
6275,"hw.module @Foo() {
    %bar = sv.reg : !hw.inout<struct<mem: !hw.array<1xstruct<sink: i1>>>>
    %0 = hw.aggregate_constant [[[false]]] : !hw.struct<mem: !hw.array<1xstruct<sink: i1>>>
    sv.assign %bar, %0 : !hw.struct<mem: !hw.array<1xstruct<sink: i1>>>
}","module Foo();
  struct packed {struct packed {logic sink; }[0:0] mem; } bar;
  assign bar = '{mem: {'{sink: 1'h0}}};
endmodule",,,,,,,,
6272,"circuit Foo:
  module Foo:
    input r: {addr: UInt<3>, en: UInt<1> clk: Clock, flip data: {a: Clock}}
    input w: {addr: UInt<3>, en: UInt<1> clk: Clock, data: {a: Clock}, mask: {a: UInt<1>}}

    mem memory:
      data-type => {a: Clock}
      depth => 16
      reader => r
      writer => w
      read-latency => 1
      write-latency => 1
      read-under-write => undefined

    memory.r <= r
    memory.w <= w","Memory.fir:6:5: error: 'hw.wire' op requires the same type for all operands and results
    mem memory:
    ^
Memory.fir:6:5: note: see current operation: %2 = ""hw.wire""(%5) {name = ""memory_r_data_a""} : (i1) -> !seq.clock","#loc = loc(""Memory.fir"":3:11)
#loc1 = loc(""Memory.fir"":4:11)
""builtin.module""() ({
  ""hw.module""() ({
  ^bb0(%arg0: i3, %arg1: i1, %arg2: !seq.clock, %arg3: i3, %arg4: i1, %arg5: !seq.clock, %arg6: !seq.clock, %arg7: i1):
    %0 = ""hw.constant""() {value = false} : () -> i1
    %1 = ""hw.wire""(%7) {name = ""memory_r_addr""} : (i4) -> i4
    %2 = ""hw.wire""(%5) {name = ""memory_r_data_a""} : (i1) -> !seq.clock
    %3 = ""hw.wire""(%8) {name = ""memory_w_addr""} : (i4) -> i4
    %4 = ""seq.firmem""() <{name = ""memory_a"", prefix = """", readLatency = 1 : i32, ruw = 0 : i32, writeLatency = 1 : i32, wuw = 1 : i32}> : () -> !seq.firmem<16 x 1>
    %5 = ""seq.firmem.read_port""(%4, %1, %arg2, %arg1) : (!seq.firmem<16 x 1>, i4, !seq.clock, i1) -> i1
    %6 = ""comb.and""(%arg4, %arg7) <{twoState}> : (i1, i1) -> i1
    ""seq.firmem.write_port""(%4, %3, %arg5, %6, %arg6) <{operandSegmentSizes = array<i32: 1, 1, 1, 1, 1, 0>}> : (!seq.firmem<16 x 1>, i4, !seq.clock, i1, !seq.clock) -> ()
    %7 = ""comb.concat""(%0, %arg0) : (i1, i3) -> i4
    %8 = ""comb.concat""(%0, %arg3) : (i1, i3) -> i4
    ""hw.output""(%2) : (!seq.clock) -> ()
  }) {argLocs = [#loc, #loc, #loc, #loc1, #loc1, #loc1, #loc1, #loc1], argNames = [""r_addr"", ""r_en"", ""r_clk"", ""w_addr"", ""w_en"", ""w_clk"", ""w_data_a"", ""w_mask_a""], arg_attrs = [{}, {}, {}, {}, {}, {}, {}, {}], comment = """", function_type = (i3, i1, !seq.clock, i3, i1, !seq.clock, !seq.clock, i1) -> !seq.clock, parameters = [], res_attrs = [{}], resultLocs = [#loc], resultNames = [""r_data_a""], sym_name = ""Foo""} : () -> ()
}) : () -> ()","// Generated by CIRCT firtool-1.53.0
// VCS coverage exclude_file
module memory_a_16x1(
  input  [3:0] R0_addr,
  input        R0_en,
               R0_clk,
  input  [3:0] W0_addr,
  input        W0_en,
               W0_clk,
               W0_data,
  output       R0_data
);

  reg       Memory[0:15];
  reg       _R0_en_d0;
  reg [3:0] _R0_addr_d0;
  always @(posedge R0_clk) begin
    _R0_en_d0 <= R0_en;
    _R0_addr_d0 <= R0_addr;
  end // always @(posedge)
  always @(posedge W0_clk) begin
    if (W0_en)
      Memory[W0_addr] <= W0_data;
  end // always @(posedge)
  assign R0_data = _R0_en_d0 ? Memory[_R0_addr_d0] : 1'bx;
endmodule

module Foo(
  input  [2:0] r_addr,
  input        r_en,
               r_clk,
  input  [2:0] w_addr,
  input        w_en,
               w_clk,
               w_data_a,
               w_mask_a,
  output       r_data_a
);

  memory_a_16x1 memory_a_ext (
    .R0_addr ({1'h0, r_addr}),
    .R0_en   (r_en),
    .R0_clk  (r_clk),
    .W0_addr ({1'h0, w_addr}),
    .W0_en   (w_en & w_mask_a),
    .W0_clk  (w_clk),
    .W0_data (w_data_a),
    .R0_data (r_data_a)
  );
endmodule",,,,,,
6226,"hw.module @Bar0(in %0: i1) {
}

hw.module @Bar1(in %a: i1) {
}

hw.module @Bar2(in %0 ""space here"" : i1) {
}

hw.module @Bar3(in %b ""space here"" : i1) {
}",,,,,,,,,
6193,"#0 0x00007ff7b9dca204 (d:\a\circt\circt\build\bin\firtool.exe+0x1fa204)
 #1 0x00007ff7b9dd00a1 (d:\a\circt\circt\build\bin\firtool.exe+0x2000a1)
 #2 0x00007ff7ba5f0107 (d:\a\circt\circt\build\bin\firtool.exe+0xa20107)
 #3 0x00007ff7ba5f5a27 (d:\a\circt\circt\build\bin\firtool.exe+0xa25a27)
 #4 0x00007ff7ba5f7529 (d:\a\circt\circt\build\bin\firtool.exe+0xa27529)
 #5 0x00007ff7ba5f0616 (d:\a\circt\circt\build\bin\firtool.exe+0xa20616)
 #6 0x00007ff7ba5f6ee2 (d:\a\circt\circt\build\bin\firtool.exe+0xa26ee2)
 #7 0x00007ff7ba5f00f2 (d:\a\circt\circt\build\bin\firtool.exe+0xa200f2)
 #8 0x00007ff7ba5f5a27 (d:\a\circt\circt\build\bin\firtool.exe+0xa25a27)
 #9 0x00007ff7ba5f61fd (d:\a\circt\circt\build\bin\firtool.exe+0xa261fd)
#10 0x00007ff7b9be0544 (d:\a\circt\circt\build\bin\firtool.exe+0x10544)
#11 0x00007ff7b9be09ff (d:\a\circt\circt\build\bin\firtool.exe+0x109ff)
#12 0x00007ff7b9bdee3b (d:\a\circt\circt\build\bin\firtool.exe+0xee3b)
#13 0x00007ff7b9be26df (d:\a\circt\circt\build\bin\firtool.exe+0x126df)
#14 0x00007ff7ba60d560 (d:\a\circt\circt\build\bin\firtool.exe+0xa3d560)
#15 0x00007ffe8a4c7ac4 (C:\Windows\System32\KERNEL32.DLL+0x17ac4)
#16 0x00007ffe8bfda351 (C:\Windows\SYSTEM32\ntdll.dll+0x5a351)","WARNING: Unable to resolve package source 'https://www.powershellgallery.com/api/v2'.
Install-Package: No match was found for the specified search criteria and module name 'VSSetup'. Try Get-PSRepository to see all
available registered module repositories.

Error: Process completed with exit code 1.","Install-Package: No match was found for the specified search criteria and module name 'VSSetup'. Try Get-PSRepository to see all
available registered module repositories.

Error: Process completed with exit code 1.",,,,,,,
6074,"firrtl.circuit ""ClockProbe"" {
  firrtl.module @ClockProbe(in %in: !firrtl.clock, out %out: !firrtl.clock) attributes {convention = #firrtl<convention scalarized>} {
    %0 = firrtl.ref.send %in : !firrtl.clock
    %1 = firrtl.ref.resolve %0 : !firrtl.probe<clock>
    firrtl.strictconnect %out, %1 : !firrtl.clock
  }
}","LLVM ERROR: can't create type 'circt::seq::ClockType' because storage uniquer isn't initialized: the dialect was likely not loaded, or the type wasn't added with addTypes<...>() in the Dialect::initialize() method.
PLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.
Stack dump:
0.	Program arguments: ./build/bin/circt-opt --firrtl-lower-xmr ./clock-probe.mlir",,,,,,,,
6059,"// -----
// Test that annotations keep ports alive.
// CHECK-LABEL: ""AnnoAlivePort""
firrtl.circuit ""AnnoAlivePort"" {
  // CHECK: module private @AnnoPort
  firrtl.module private @AnnoPort(out %dead : !firrtl.uint<5> [{class = ""circt.test""}]) {}
  firrtl.module @AnnoAlivePort() {
    // CHECK: firrtl.instance
    %inst_dead = firrtl.instance inst @AnnoPort(out dead : !firrtl.uint<5>)
  }
}","firrtl.circuit ""AnnoAlivePort"" {
  firrtl.module private @AnnoPort() {
    %0 = firrtl.wire : !firrtl.uint<5>
  }
  firrtl.module @AnnoAlivePort() {
    firrtl.instance inst @AnnoPort()
  }
}",,,,,,,,
6013,"FIRRTL version 4.0.0
circuit RANDOM:
  module RANDOM:
    input clock: Clock
    input d: UInt<1>
    output q: UInt<1>

    reg r: UInt<1>, clock

    connect r, d
    connect q, r","<unknown>:0: error: Referenced macro doesn't exist ""ENABLE_INITIAL_MEM_""
<unknown>:0: note: see current operation: ""sv.macro.def""() {format_string = """", macroName = @ENABLE_INITIAL_MEM_, symbols = []} : () -> ()",,,,,,,,
5886,"circuit ResetEnum:
  module ResetEnum:
    input in : {| Some: UInt<1> |}
    output out: {| Some: Reset |}
    out <= in",,,,,,,,,
5884,"circuit EnumConst:
  module EnumConst:
    input e : {| Some : const UInt<8>, None |}","circuit ConstEnumConst:
  module ConstEnumConst:
    input e : const {| Some : const UInt<8>, None |}",,,,,,,,
5772,"hw.type_scope @__hw_typedecls {
  hw.typedecl @foo : i1
}

hw.module @Top(%arg0: !hw.typealias<@__hw_typedecls::@foo,i1>) {
  %0 = comb.concat %arg0 : !hw.typealias<@__hw_typedecls::@foo,i1>
}","circt-opt: /scratch/hidetou/circt/llvm/llvm/include/llvm/Support/Casting.h:566: decltype(auto) llvm::cast(const From &) [To = mlir::IntegerType, From = mlir::Type]: Assertion `isa<To>(Val) && ""cast<Ty>() argument of incompatible type!""' failed.
PLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.
Stack dump:
0.      Program arguments: ./build/bin/circt-opt foo.mlir
1.      MLIR Parser: custom op parser 'hw.module'
2.      MLIR Parser: custom op parser 'comb.concat'
 #0 0x0000000000447057 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /scratch/hidetou/circt/llvm/llvm/lib/Support/Unix/Signals.inc:602:13
 #1 0x00000000004451e0 llvm::sys::RunSignalHandlers() /scratch/hidetou/circt/llvm/llvm/lib/Support/Signals.cpp:105:18
 #2 0x000000000044796f SignalHandler(int) /scratch/hidetou/circt/llvm/llvm/lib/Support/Unix/Signals.inc:413:1
 #3 0x00007fe418fd6cf0 __restore_rt (/lib64/libpthread.so.0+0x12cf0)
 #4 0x00007fe417e61aff raise (/lib64/libc.so.6+0x4eaff)
 #5 0x00007fe417e34ea5 abort (/lib64/libc.so.6+0x21ea5)
 #6 0x00007fe417e34d79 _nl_load_domain.cold.0 (/lib64/libc.so.6+0x21d79)
 #7 0x00007fe417e5a456 (/lib64/libc.so.6+0x47456)
 #8 0x0000000000609c3b (./build/bin/circt-opt+0x609c3b)
 #9 0x000000000060c749 circt::comb::ConcatOp::inferReturnTypes(mlir::MLIRContext*, std::optional<mlir::Location>, mlir::ValueRange, mlir::DictionaryAttr, mlir::OpaqueProperties, mlir::RegionRange, llvm::SmallVectorImpl<mlir::Type>&) /scratch/hidetou/circt/lib/Dialect/Comb/CombOps.cpp:270:21
#10 0x000000000060c749 circt::comb::ConcatOp::parse(mlir::OpAsmParser&, mlir::OperationState&) /scratch/hidetou/circt/build/tools/circt/include/circt/Dialect/Comb/Comb.cpp.inc:948:22
#11 0x00000000014d521f mlir::LogicalResult::failed() const /scratch/hidetou/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33
#12 0x00000000014d521f mlir::ParseResult::operator bool() const /scratch/hidetou/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:126:43
#13 0x00000000014d521f (anonymous namespace)::CustomOpAsmParser::parseOperation(mlir::OperationState&) /scratch/hidetou/circt/llvm/mlir/lib/AsmParser/Parser.cpp:1491:9
#14 0x00000000014d521f (anonymous namespace)::OperationParser::parseCustomOperation(llvm::ArrayRef<std::tuple<llvm::StringRef, unsigned int, llvm::SMLoc>>) /scratch/hidetou/circt/llvm/mlir/lib/AsmParser/Parser.cpp:1987:19
#15 0x00000000014d521f (anonymous namespace)::OperationParser::parseOperation() /scratch/hidetou/circt/llvm/mlir/lib/AsmParser/Parser.cpp:1146:10
#16 0x00000000014e0ac0 mlir::LogicalResult::failed() const /scratch/hidetou/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33
#17 0x00000000014e0ac0 mlir::ParseResult::operator bool() const /scratch/hidetou/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:126:43
#18 0x00000000014e0ac0 (anonymous namespace)::OperationParser::parseBlockBody(mlir::Block*) /scratch/hidetou/circt/llvm/mlir/lib/AsmParser/Parser.cpp:2263:9
#19 0x00000000014e0ac0 (anonymous namespace)::OperationParser::parseBlock(mlir::Block*&) /scratch/hidetou/circt/llvm/mlir/lib/AsmParser/Parser.cpp:2193:12",,,,,,,,
5727,"firrtl.circuit ""Foo"" {
  firrtl.module @Foo(out %a: !firrtl.probe<uint<1>>, out %a0: !firrtl.probe<uint<1>>) attributes {convention = #firrtl<convention scalarized>, portNames = [""a"", ""a""]} {
    %b = firrtl.wire interesting_name : !firrtl.uint<1>
    %0 = firrtl.ref.send %b : !firrtl.uint<1>
    firrtl.ref.define %a, %0 : !firrtl.probe<uint<1>>
    %1 = firrtl.ref.send %b : !firrtl.uint<1>
    firrtl.ref.define %a0, %1 : !firrtl.probe<uint<1>>
  }
}","# circt-opt Foo.mlir -firrtl-lower-xmr                                   
firrtl-snippets/issues/x.mlir:3:5: error: redefinition of symbol named 'ref_Foo_Foo_a'
    firrtl.module @Foo(out %a: !firrtl.probe<uint<1>>, out %a0: !firrtl.probe<uint<1>>) attributes {convention = #firrtl<convention scalarized>, portNames = [""a"", ""a""]} {
    ^
firrtl-snippets/issues/x.mlir:3:5: note: see current operation: ""sv.macro.decl""() {sym_name = ""ref_Foo_Foo_a""} : () -> ()
firrtl-snippets/issues/x.mlir:3:5: note: see existing symbol definition here",,,,,,,,
5721,"firrtl.circuit ""Foo"" {
  firrtl.module @Foo() {
    %0 = firrtl.wire {name = ""a""} : !firrtl.uint<1>
    %1 = firrtl.wire {name = ""a""} : !firrtl.uint<1>
  }
}","FIRRTL version 3.1.0
circuit Foo :
  module Foo : 
    wire a : UInt<1> 
    wire a : UInt<1>",,,,,,,,
5590,"module {
  firrtl.circuit ""OMIRField"" {
    firrtl.module @OMIRField(in %x_b: !firrtl.uint<0>, out %y_b: !firrtl.uint<0>) {
      %n_b = firrtl.node sym @omir_sym %x_b : !firrtl.uint<0>
      firrtl.strictconnect %y_b, %n_b : !firrtl.uint<0>
    }
  }
  sv.verbatim ""Testing {{0}}"" {symbols = [#hw.innerNameRef<@OMIRField::@omir_sym>]}
}","module {
  sv.verbatim ""Testing {{0}}"" {symbols = [#hw.innerNameRef<@OMIRField::@omir_sym>]}
  hw.module @OMIRField() {
    hw.output
  }
}","omir_zw_field_issue.mlir:8:3: error: cannot get name for symbol #hw.innerNameRef<@OMIRField::@omir_sym>
  sv.verbatim ""Testing {{0}}"" {symbols = [#hw.innerNameRef<@OMIRField::@omir_sym>]}
  ^
omir_zw_field_issue.mlir:8:3: note: see current operation: ""sv.verbatim""() {format_string = ""Testing {{0}}"", symbols = [#hw.innerNameRef<@OMIRField::@omir_sym>]} : () -> ()
// Generated by CIRCT 1.46.0g20230714_98d0bf5
Testing <INVALID>	// omir_zw_field_issue.mlir:8:3
module OMIRField();	// omir_zw_field_issue.mlir:3:5
endmodule","module {
  firrtl.circuit ""OMIRField"" {
    firrtl.module @OMIRField(in %x_b: !firrtl.uint<0> sym @omir_sym, out %y_b: !firrtl.uint<0>) {
      %n_b = firrtl.node %x_b : !firrtl.uint<0>
      firrtl.strictconnect %y_b, %n_b : !firrtl.uint<0>
    }
  }
  sv.verbatim ""Testing {{0}}"" {symbols = [#hw.innerNameRef<@OMIRField::@omir_sym>]}
}","omir_zw_field_issue.mlir:3:33: error: zero width port ""x_b"" is referenced by name [#hw<innerSym@omir_sym>] (e.g. in an XMR) but must be removed
    firrtl.module @OMIRField(in %x_b: !firrtl.uint<0> sym @omir_sym, out %y_b: !firrtl.uint<0>) {
                                ^",,,,,
5566,"hw.module @unsupported(%a: !hw.inout<i42>) {
  %clock = hw.constant 1 : i1
  %c42 = hw.constant 42 : i42
  sv.alwaysff(posedge %clock) {
    sv.passign %a, %c42 : i42
  }
}",,,,,,,,,
5562,"firrtl.circuit ""Foo"" {
  firrtl.module @Foo() {}
  firrtl.module @Bar(in %a: !firrtl.uint<1>, out %b: !firrtl.probe<uint<1>>) {
    %0 = firrtl.ref.send %a : !firrtl.uint<1>
    firrtl.ref.define %b, %0 : !firrtl.probe<uint<1>>
  }
}","Assertion failed: ((!result || !isa<FIRRTLType>(result.getType())) && ""Lowering didn't turn a FIRRTL value into a non-FIRRTL value""), function setLowering, file LowerToHW.cpp, line 2338.",,,,,,,,
5483,"module {
  hw.module @EXPLODE(%0: i64, %1: i64) -> (arg1: i64, arg2: i64) {
    %2 = hw.struct_create (%0, %1) : !hw.struct<arg1: i64, arg2: i64>
    %arg1, %arg2 = hw.struct_explode %2 : !hw.struct<arg1: i64, arg2: i64>

    hw.output %arg1, %arg2 : i64, i64
  }
}","circt-opt: circt/lib/Conversion/ExportVerilog/ExportVerilog.cpp:3295:
void (anonymous namespace)::NameCollector::collectNames(mlir::Block &): 
Assertion `(!isExpr || isExpressionEmittedInline(&op, moduleEmitter.state.options))
 && ""If 'op' is a verilog expression, the expression must be inlinable. "" 
 ""Otherwise, it is a bug of PrepareForEmission""' failed.",,,,,,,,
5462,"circuit Loop:
  module Loop:
    wire w : {a: UInt<8>}
    node n = w
    w <= n","circuit Loop:
  module Child:
    input bundle : { a : UInt<1>, b : UInt<1> }
    output p : {a : UInt<1>, b : UInt<1> }

    node n = bundle

    p <= n
  module Loop:
    input x : UInt<1>

    inst c of Child
    c.bundle.a <= x
    c.bundle.b <= c.p.b","circuit Loop:
  module Loop:
    input in : {a: UInt<8>}
    output out : {a: UInt<8>}
    input c : UInt<1>

    wire w : {a: UInt<8>}
    node n = w
    w <= mux(c, n, in)

    out <= w",,,,,,,
5447,,,,,,,,,,
5355,"$ ./build/bin/firtool perf/regress/chipyard.TestHarness.RocketSmall1Medium1Big1_BoomMedium1Large1Mega1.top.v.hi.fir -o foo.sv --lowering-options=disallowLocalVariables,disallowPackedArrays
Arbiters.scala:42:16: error: unsupported packed array expression
Arbiters.scala:42:16: note: see current operation: %57 = ""hw.array_concat""(%3, %56) : (!hw.array<3xi1>, !hw.array<5xi1>) -> !hw.array<8xi1>",,,,,,,,,
5205,"firrtl.circuit ""ProbeConstant"" {
  firrtl.module @ProbeConstant(out %bore: !firrtl.probe<uint<1>>) {
    %c0_ui1 = firrtl.constant 0 : !firrtl.uint<1> {name = ""internalWire""}
    %0 = firrtl.ref.send %c0_ui1 : !firrtl.uint<1>
    firrtl.ref.define %bore, %0 : !firrtl.probe<uint<1>>
  }
}","circuit ProbeConstant :
  module ProbeConstant :
    output bore : Probe<UInt<1>>

    define bore = probe(UInt<1>(0)) @[export_probe_constant.mlir 5:5]","<stdin>:5:25: error: use of unknown declaration 'UInt'
    define bore = probe(UInt<1>(0)) @[export_probe_constant.mlir 5:5]",,,,,,,
5204,"firrtl.circuit ""Foo"" {
  firrtl.module @Foo(in %clock: !firrtl.clock, in %a: !firrtl.uint<1>, out %b: !firrtl.uint<1>) {
    %c1_ui1 = firrtl.constant 1 : !firrtl.uint<1>
    %0 = firrtl.wire : !firrtl.uint<1>
    %r = firrtl.regreset interesting_name %clock, %c1_ui1, %0 : !firrtl.clock, !firrtl.uint<1>, !firrtl.uint<1>, !firrtl.uint<1>
    firrtl.strictconnect %0, %r : !firrtl.uint<1>
  }
}","Assertion failed: (!s->text().empty() && ""empty string token""), function operator(), file PrettyPrinter.cpp, line 91.
PLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.
Stack dump:
0.      Program arguments: circt-translate -export-firrtl Bar.mlir
Stack dump without symbol names (ensure you have llvm-symbolizer in your PATH or set the environment var `LLVM_SYMBOLIZER_PATH` to point to it):
0  circt-translate          0x00000001079167ed llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) + 61
1  circt-translate          0x0000000107916d5b PrintStackTraceSignalHandler(void*) + 27
2  circt-translate          0x0000000107914896 llvm::sys::RunSignalHandlers() + 134
3  circt-translate          0x0000000107918b8f SignalHandler(int) + 223
4  libsystem_platform.dylib 0x00007ff81820c5ed _sigtramp + 29
5  libsystem_platform.dylib 0x00007ff7b877dd20 _sigtramp + 18446744072104646480
6  libsystem_c.dylib        0x00007ff818105b45 abort + 123
7  libsystem_c.dylib        0x00007ff818104e5e err + 0
8  circt-translate          0x0000000108746000 circt::pretty::PrettyPrinter::add(circt::pretty::Token)::$_1::operator()(circt::pretty::StringToken*) const + 176
9  circt-translate          0x0000000108745ee8 llvm::TypeSwitch<circt::pretty::Token*, void>& llvm::TypeSwitch<circt::pretty::Token*, void>::Case<circt::pretty::StringToken, circt::pretty::PrettyPrinter::add(circt::pretty::Token)::$_1>(circt::pretty::PrettyPrinter::add(circt::pretty::Token)::$_1&&) + 88
10 circt-translate          0x0000000108744af5 llvm::TypeSwitch<circt::pretty::Token*, void>& llvm::detail::TypeSwitchBase<llvm::TypeSwitch<circt::pretty::Token*, void>, circt::pretty::Token*>::Case<circt::pretty::PrettyPrinter::add(circt::pretty::Token)::$_1>(circt::pretty::PrettyPrinter::add(circt::pretty::Token)::$_1&&) + 53
11 circt-translate          0x0000000108744a03 circt::pretty::PrettyPrinter::add(circt::pretty::Token) + 99
12 circt-translate          0x000000010819d235 std::__1::enable_if<std::is_base_of_v<circt::pretty::Token, circt::pretty::StringToken>, void>::type circt::pretty::TokenBuilder<circt::pretty::PrettyPrinter>::add<circt::pretty::StringToken, llvm::StringRef&>(llvm::StringRef&) + 101
13 circt-translate          0x000000010819d1c1 circt::pretty::TokenBuilder<circt::pretty::PrettyPrinter>::literal(llvm::StringRef) + 33
14 circt-translate          0x000000010819c118 circt::pretty::TokenStream<circt::pretty::PrettyPrinter>::operator<<(circt::pretty::PPExtString const&) + 56
15 circt-translate          0x00000001081c2fa8 (anonymous namespace)::Emitter::emitStatement(circt::firrtl::WireOp)::$_5::operator()() const + 104
16 circt-translate          0x00000001081c2f35 decltype(static_cast<(anonymous namespace)::Emitter::emitStatement(circt::firrtl::WireOp)::$_5>(fp)()) std::__1::__invoke<(anonymous namespace)::Emitter::emitStatement(circt::firrtl::WireOp)::$_5>((anonymous namespace)::Emitter::emitStatement(circt::firrtl::WireOp)::$_5&&) + 21
17 circt-translate          0x00000001081c2e5d std::__1::invoke_result<(anonymous namespace)::Emitter::emitStatement(circt::firrtl::WireOp)::$_5>::type std::__1::invoke<(anonymous namespace)::Emitter::emitStatement(circt::firrtl::WireOp)::$_5>((anonymous namespace)::Emitter::emitStatement(circt::firrtl::WireOp)::$_5&&) + 29
18 circt-translate          0x00000001081c2d96 auto circt::pretty::TokenStream<circt::pretty::PrettyPrinter>::scopedBox<circt::pretty::PP, (anonymous namespace)::Emitter::emitStatement(circt::firrtl::WireOp)::$_5>(circt::pretty::PP&&, (anonymous namespace)::Emitter::emitStatement(circt::firrtl::WireOp)::$_5&&, circt::pretty::Token) + 102
19 circt-translate          0x00000001081c2d13 (anonymous namespace)::Emitter::emitStatement(circt::firrtl::WireOp) + 179
20 circt-translate          0x00000001081c2808 auto (anonymous namespace)::Emitter::emitStatementsInBlock(mlir::Block&)::$_16::operator()<circt::firrtl::WireOp>(circt::firrtl::WireOp) const + 40
21 circt-translate          0x00000001081c278b llvm::TypeSwitch<mlir::Operation*, void>& llvm::TypeSwitch<mlir::Operation*, void>::Case<circt::firrtl::WireOp, (anonymous namespace)::Emitter::emitStatementsInBlock(mlir::Block&)::$_16&>((anonymous namespace)::Emitter::emitStatementsInBlock(mlir::Block&)::$_16&) + 107
22 circt-translate          0x000000010819ea0d (anonymous namespace)::Emitter::emitStatementsInBlock(mlir::Block&) + 365
23 circt-translate          0x000000010819e669 (anonymous namespace)::Emitter::emitModule(circt::firrtl::FModuleOp)::$_1::operator()() const + 217",,,,,,,,
5202,"circuit Foo :
  module Foo :
    input clock: Clock
    input a: UInt<1>
    output b: UInt<1>

    reg r: UInt<1>, clock with: (reset => (UInt<1>(1), r))

    r <= a
    b <= r","module Foo(
  input  clock,
         a,
  output b
);

  reg r;
  always @(posedge clock)
    r <= a;
  assign b = r;
endmodule","module Foo(
  input   clock,
  input   a,
  output  b
);
  assign b = 1'h0;
endmodule",,,,,,,
5031,,,,,,,,,,
4921,"module {
  firrtl.circuit ""Unreachable"" {
    hw.hierpath private @nla_5560 [@Unreachable::@w, @Bar2]
    hw.hierpath private @nla_5561 [@Bar1::@w, @Bar3]
    firrtl.module private @Bar2() attributes {annotations = [{class = ""firrtl.passes.InlineAnnotation""}]} {
      %x = firrtl.wire sym @x {annotations = [{circt.nonlocal = @nla_5560, class = ""test0""}]} : !firrtl.uint<8>
      firrtl.instance no sym @no @Bar1()
    }
    firrtl.module private @Bar1() attributes {annotations = [{class = ""firrtl.passes.InlineAnnotation""}]} {
      firrtl.instance bar3 sym @w @Bar3()
    }
    firrtl.module private @Bar3() attributes {annotations = [{class = ""firrtl.passes.InlineAnnotation""}]} {
      %w = firrtl.wire sym @w {annotations = [{circt.nonlocal = @nla_5561, class = ""test0""}]} : !firrtl.uint<8>
    }
    firrtl.module @Unreachable() {
      firrtl.instance no sym @no @Bar1()
      firrtl.instance bar2 sym @w @Bar2()
    }
  }
}","the default constructor for MutableNLA should never be used
UNREACHABLE executed at /home/will/src/sifive/circt/lib/Dialect/FIRRTL/Transforms/ModuleInliner.cpp:130!","* thread #1, name = 'circt-opt', stop reason = signal SIGABRT
  * frame #0: 0x00007ffff7a8abc7 libc.so.6`__pthread_kill_implementation + 295
    frame #1: 0x00007ffff7a3db46 libc.so.6`raise + 22
    frame #2: 0x00007ffff7a284b5 libc.so.6`abort + 215
    frame #3: 0x00005555561857bf circt-opt`llvm::llvm_unreachable_internal(msg=<unavailable>, file=<unavailable>, line=<unavailable>) at ErrorHandling.cpp:212:3
    frame #4: 0x0000555556788dba circt-opt`llvm::DenseMapBase<llvm::DenseMap<mlir::Attribute, (anonymous namespace)::MutableNLA, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA> >, mlir::Attribute, (anonymous namespace)::MutableNLA, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA> >::operator[](mlir::Attribute const&) [inlined] (anonymous namespace)::MutableNLA::MutableNLA(this=<unavailable>) at ModuleInliner.cpp:129:5
    frame #5: 0x0000555556788d2e circt-opt`llvm::DenseMapBase<llvm::DenseMap<mlir::Attribute, (anonymous namespace)::MutableNLA, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA> >, mlir::Attribute, (anonymous namespace)::MutableNLA, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA> >::operator[](mlir::Attribute const&) [inlined] llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA>* llvm::DenseMapBase<llvm::DenseMap<mlir::Attribute, (anonymous namespace)::MutableNLA, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, (this=<unavailable>, TheBucket=<unavailable>, Key=0x00007fffffff3db8)::MutableNLA> >, mlir::Attribute, (anonymous namespace)::MutableNLA, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA> >::InsertIntoBucket<mlir::Attribute const&>(llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA>*, mlir::Attribute const&) at DenseMap.h:563:37
    frame #6: 0x0000555556788d20 circt-opt`llvm::DenseMapBase<llvm::DenseMap<mlir::Attribute, (anonymous namespace)::MutableNLA, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA> >, mlir::Attribute, (anonymous namespace)::MutableNLA, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA> >::operator[](mlir::Attribute const&) [inlined] llvm::DenseMapBase<llvm::DenseMap<mlir::Attribute, (anonymous namespace)::MutableNLA, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA> >, mlir::Attribute, (anonymous namespace)::MutableNLA, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA> >::FindAndConstruct(this=<unavailable>, Key=0x00007fffffff3db8) at DenseMap.h:339:13
    frame #7: 0x0000555556788ce2 circt-opt`llvm::DenseMapBase<llvm::DenseMap<mlir::Attribute, (anonymous namespace)::MutableNLA, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA> >, mlir::Attribute, (anonymous namespace)::MutableNLA, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA> >::operator[](this=<unavailable>, Key=0x00007fffffff3db8) at DenseMap.h:343:12
    frame #8: 0x0000555556789f68 circt-opt`(anonymous namespace)::Inliner::setActiveHierPaths(this=0x00007fffffff4588, moduleName=StringAttr @ rbx, instInnerSym=StringAttr @ scalar) at ModuleInliner.cpp:596:11
    frame #9: 0x000055555678e194 circt-opt`(anonymous namespace)::Inliner::inlineInto(this=0x00007fffffff4588, prefix=(Data = ""bar2_"", Length = 5), b=0x00007fffffff4470, mapper=0x00007fffffff42b0, beb=0x00007fffffff41a0, edges=<unavailable>, target=FModuleOp @ 0x00007fffffff3f18, symbolRenames=<unavailable>, moduleNamespace=<unavailable>) at ModuleInliner.cpp:1094:5
    frame #10: 0x0000555556786644 circt-opt`(anonymous namespace)::Inliner::run() at ModuleInliner.cpp:1206:7
    frame #11: 0x0000555556785b4d circt-opt`(anonymous namespace)::Inliner::run(this=0x00007fffffff4588) at ModuleInliner.cpp:1325:7
    frame #12: 0x00005555567838f2 circt-opt`(anonymous namespace)::InlinerPass::runOnOperation(this=<unavailable>) at ModuleInliner.cpp:1447:13
    frame #13: 0x000055555795f79e circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] mlir::detail::OpToOpPassAdaptor::run(this=0x00007fffffff47c8)::$_7::operator()() const at Pass.cpp:482:17
    frame #14: 0x000055555795f76d circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] void llvm::function_ref<void ()>::callback_fn<mlir::detail::OpToOpPassAdaptor::run(callable=140737488308168)::$_7>(long) at STLFunctionalExtras.h:45:12
    frame #15: 0x000055555795f76d circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] llvm::function_ref<void ()>::operator(this=<unavailable>)() const at STLFunctionalExtras.h:68:12
    frame #16: 0x000055555795f76d circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] void mlir::MLIRContext::executeAction<mlir::PassExecutionAction, mlir::Pass&>(this=<unavailable>, actionFn=mlir::function_ref<void ()> @ 0x000000000330afe0, irUnits=ArrayRef<mlir::IRUnit> @ 0x000000000331dee0, args=0x0000555557bfe4f0)>, llvm::ArrayRef<mlir::IRUnit>, mlir::Pass&) at MLIRContext.h:275:7
    frame #17: 0x000055555795f75d circt-opt`mlir::detail::OpToOpPassAdaptor::run(pass=0x0000555557bfe4f0, op=<unavailable>, am=AnalysisManager @ 0x00007fffffff47a0, verifyPasses=true, parentInitGeneration=1) at Pass.cpp:476:21
    frame #18: 0x000055555795ff41 circt-opt`mlir::detail::OpToOpPassAdaptor::runPipeline(pm=0x0000555557be0d10, op=0x0000555557bfd560, am=AnalysisManager @ 0x00007fffffff4920, verifyPasses=<unavailable>, parentInitGeneration=1, instrumentor=0x0000000000000000, parentInfo=0x00007fffffff49e0) at Pass.cpp:548:16
    frame #19: 0x0000555557963336 circt-opt`mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(this=0x00007fffffff4a10, opInfo=0x0000555557c00380)::$_15::operator()(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&) const at Pass.cpp:768:36
    frame #20: 0x000055555796150b circt-opt`mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) [inlined] mlir::LogicalResult mlir::failableParallelForEach<__gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15&>(context=0x00007fffffff4f80, begin=__normal_iterator<OpPMInfo *, std::vector<OpPMInfo, std::allocator<OpPMInfo> > > @ 0x00007fffffff4a90, end=__normal_iterator<OpPMInfo *, std::vector<OpPMInfo, std::allocator<OpPMInfo> > > @ 0x00007fffffff49a0, func=0x00007fffffff4a10)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15&) at Threading.h:46:18
    frame #21: 0x00005555579612f5 circt-opt`mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) [inlined] mlir::LogicalResult mlir::failableParallelForEach<std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> >&, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15&>(context=0x00007fffffff4f80, range=<unavailable>, func=0x00007fffffff4a10)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> >&, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15&) at Threading.h:92:10
    frame #22: 0x00005555579612f5 circt-opt`mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(this=0x0000555557b8c020, verifyPasses=<unavailable>) at Pass.cpp:778:14
    frame #23: 0x000055555795f8f4 circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] mlir::detail::OpToOpPassAdaptor::runOnOperation(this=0x0000555557b8c020, verifyPasses=<unavailable>) at Pass.cpp:669:5
    frame #24: 0x000055555795f8cb circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] mlir::detail::OpToOpPassAdaptor::run(this=0x00007fffffff4b78)::$_7::operator()() const at Pass.cpp:480:20
    frame #25: 0x000055555795f8b6 circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] void llvm::function_ref<void ()>::callback_fn<mlir::detail::OpToOpPassAdaptor::run(callable=140737488309112)::$_7>(long) at STLFunctionalExtras.h:45:12
    frame #26: 0x000055555795f8b6 circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] llvm::function_ref<void ()>::operator(this=<unavailable>)() const at STLFunctionalExtras.h:68:12
    frame #27: 0x000055555795f8b6 circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] void mlir::MLIRContext::executeAction<mlir::PassExecutionAction, mlir::Pass&>(this=<unavailable>, actionFn=mlir::function_ref<void ()> @ 0x0000000003435460, irUnits=ArrayRef<mlir::IRUnit> @ 0x00000000038b4fc0, args=0x0000555557b8c020)>, llvm::ArrayRef<mlir::IRUnit>, mlir::Pass&) at MLIRContext.h:275:7
    frame #28: 0x000055555795f8b6 circt-opt`mlir::detail::OpToOpPassAdaptor::run(pass=0x0000555557b8c020, op=<unavailable>, am=AnalysisManager @ 0x00007fffffff4b50, verifyPasses=true, parentInitGeneration=1) at Pass.cpp:476:21
    frame #29: 0x00005555579622b3 circt-opt`mlir::PassManager::run(mlir::Operation*) at Pass.cpp:548:16
    frame #30: 0x000055555796226a circt-opt`mlir::PassManager::run(mlir::Operation*) [inlined] mlir::PassManager::runPasses(this=0x00007fffffff4e90, op=0x0000555557bfd5c0, am=AnalysisManager @ scalar) at Pass.cpp:857:10
    frame #31: 0x0000555557962251 circt-opt`mlir::PassManager::run(this=0x00007fffffff4e90, op=0x0000555557bfd5c0) at Pass.cpp:837:60
    frame #32: 0x00005555570f9579 circt-opt`performActions(os=0x0000555557b57c18, sourceMgr=std::__shared_ptr<llvm::SourceMgr, __gnu_cxx::_S_atomic>::element_type @ 0x0000555557bc9000, context=0x00007fffffff4f80, config=0x00007fffffff5448) at MlirOptMain.cpp:219:17
    frame #33: 0x00005555570f91f1 circt-opt`mlir::LogicalResult llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>::callback_fn<mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, mlir::DialectRegistry&, mlir::MlirOptMainConfig const&)::$_1>(long, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) at MlirOptMain.cpp:266:12
    frame #34: 0x00005555570f901f circt-opt`mlir::LogicalResult llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>::callback_fn<mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, mlir::DialectRegistry&, mlir::MlirOptMainConfig const&)::$_1>(long, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) [inlined] mlir::MlirOptMain(this=<unavailable>, chunkBuffer=nullptr, os=<unavailable>)::$_1::operator()(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) const at MlirOptMain.cpp:307:12
    frame #35: 0x00005555570f9011 circt-opt`mlir::LogicalResult llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>::callback_fn<mlir::MlirOptMain(callable=<unavailable>, params=<unavailable>, params=0x0000555557b57c18)::$_1>(long, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) at STLFunctionalExtras.h:45:12
    frame #36: 0x000055555711a655 circt-opt`mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool) [inlined] llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>::operator(this=0x00007fffffff51b8, params=nullptr, params=<unavailable>)(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) const at STLFunctionalExtras.h:68:12
    frame #37: 0x000055555711a63d circt-opt`mlir::splitAndProcessBuffer(originalBuffer=nullptr, processChunkBuffer=mlir::ChunkBufferHandler @ 0x00007fffffff51b8, os=0x0000555557b57c18, enableSplitting=<unavailable>, insertMarkerInOutput=true)>, llvm::raw_ostream&, bool, bool) at ToolUtilities.cpp:28:12
    frame #38: 0x00005555570f7871 circt-opt`mlir::MlirOptMain(outputStream=0x0000555557b57c18, buffer=nullptr, registry=0x00007fffffff55b8, config=0x00007fffffff5448) at MlirOptMain.cpp:310:10
    frame #39: 0x00005555570f7f71 circt-opt`mlir::MlirOptMain(argc=<unavailable>, argv=<unavailable>, toolName=<unavailable>, registry=0x00007fffffff55b8, preloadDialectsInContext=false) at MlirOptMain.cpp:407:14
    frame #40: 0x0000555556160aec circt-opt`main(argc=3, argv=0x00007fffffff5758) at circt-opt.cpp:70:23
    frame #41: 0x00007ffff7a2924e libc.so.6`__libc_start_call_main + 126
    frame #42: 0x00007ffff7a29309 libc.so.6`__libc_start_main@@GLIBC_2.34 + 137
    frame #43: 0x0000555556160415 circt-opt`_start + 37",,,,,,,
4896,"module {
  firrtl.circuit ""Oops"" {
    firrtl.module private @Child() attributes {annotations = [{circt.nonlocal = @nla, class = ""circt.test""}]} {
    }
    firrtl.module @Oops() {
      firrtl.instance child @Child()
    }
  }
}",,,,,,,,,
4886,"circuit Top : %[[
  {
    ""class"":""sifive.enterprise.firrtl.FullAsyncResetAnnotation"",
    ""target"":""~Top|FullAsyncWrapper>rf_reset""
  }
]]
  module Child :
    input clock : Clock
    input foo : UInt<8>
    output bar : UInt<8>

    reg r : UInt<8>, clock
    r <= foo
    bar <= r

  module FullAsyncWrapper :
    input clock : Clock
    input rf_reset : AsyncReset
    input foo : UInt<8>
    output bar : UInt<8>

    inst c of Child
    c.clock <= clock
    c.foo <= foo
    bar <= c.bar

  module Top :
    input clock : Clock
    input rf_reset : AsyncReset
    input foo : UInt<8>
    output bar : UInt<8>

    inst wrap of FullAsyncWrapper
    wrap.clock <= clock
    wrap.rf_reset <= rf_reset
    wrap.foo <= foo

    inst child of Child
    child.clock <= clock
    child.foo <= foo

    bar <= and(wrap.bar, child.bar)","test.fir:7:10: error: module 'Child' instantiated in different reset domains
  module Child :
         ^
test.fir:7:10: note: see current operation: 
""firrtl.module""() ({
^bb0(%arg0: !firrtl.clock, %arg1: !firrtl.uint<8>, %arg2: !firrtl.uint<8>):
  %0 = ""firrtl.reg""(%arg0) {annotations = [], name = ""r"", nameKind = #firrtl<name_kind droppable_name>} : (!firrtl.clock) -> !firrtl.uint<8>
  ""firrtl.strictconnect""(%0, %arg1) : (!firrtl.uint<8>, !firrtl.uint<8>) -> ()
  ""firrtl.strictconnect""(%arg2, %0) : (!firrtl.uint<8>, !firrtl.uint<8>) -> ()
}) {annotations = [], portAnnotations = [], portDirections = -4 : i3, portLocations = [loc(""test.fir"":8:11), loc(""test.fir"":9:11), loc(""test.fir"":10:12)], portNames = [""clock"", ""foo"", ""bar""], portSyms = [], portTypes = [!firrtl.clock, !firrtl.uint<8>, !firrtl.uint<8>], sym_name = ""Child"", sym_visibility = ""private""} : () -> ()
test.fir:22:5: note: instance 'wrap/c' is in reset domain rooted at 'rf_reset' of module 'FullAsyncWrapper'
    inst c of Child
    ^
test.fir:18:11: note: reset domain 'rf_reset' of module 'FullAsyncWrapper' declared here:
    input rf_reset : AsyncReset
          ^
test.fir:38:5: note: instance 'child' is in no reset domain
    inst child of Child
    ^",,,,,,,,
4849,"module {
  sv.interface @wire {}
  hw.module private @Foo() {
    %module = sv.interface.instance : !sv.interface<@wire>
    hw.output
  }
}","// Generated by CIRCT unknown git version
interface module_0;
endinterface

module Foo();	// Foo.mlir:3:3
  wire_0 module();	// Foo.mlir:4:15
endmodule",,,,,,,,
4842,$ circt-opt simple_arith.mlir --lower-scf-to-calyx --calyx-remove-comb-groups --canonicalize --lower-calyx-to-fsm,"$ circt-opt simple_arith.mlir --lower-scf-to-calyx --calyx-remove-comb-groups --lower-calyx-to-fsm
circt-opt: /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/SmallVector.h:303: T& llvm::SmallVectorTemplateCommon<T, <template-parameter-1-2> >::front() [with T = std::pair<mlir::Operation*, circt::fsm::StateOp>; <template-parameter-1-2> = void; reference = std::pair<mlir::Operation*, circt::fsm::StateOp>&]: Assertion `!empty()' failed","circt-opt simple_arith.mlir --lower-scf-to-calyx --calyx-remove-comb-groups --lower-calyx-to-fsm   
circt-opt: /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/SmallVector.h:303: T& llvm::SmallVectorTemplateCommon<T, <template-parameter-1-2> >::front() [with T = std::pair<mlir::Operation*, circt::fsm::StateOp>; <template-parameter-1-2> = void; reference = std::pair<mlir::Operation*, circt::fsm::StateOp>&]: Assertion `!empty()' failed.
PLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.
Stack dump:
0.	Program arguments: ../../circt/build/bin/circt-opt simple_arith.mlir --lower-scf-to-calyx --calyx-remove-comb-groups --lower-calyx-to-fsm
 #0 0x000055d161ee52d4 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/xerpi/Desktop/Research/circt/llvm/llvm/lib/Support/Unix/Signals.inc:602:22
 #1 0x000055d161ee56a6 PrintStackTraceSignalHandler(void*) /home/xerpi/Desktop/Research/circt/llvm/llvm/lib/Support/Unix/Signals.inc:676:1
 #2 0x000055d161ee2d57 llvm::sys::RunSignalHandlers() /home/xerpi/Desktop/Research/circt/llvm/llvm/lib/Support/Signals.cpp:104:20
 #3 0x000055d161ee4c32 SignalHandler(int) /home/xerpi/Desktop/Research/circt/llvm/llvm/lib/Support/Unix/Signals.inc:413:1
 #4 0x00007f117de51f50 (/usr/lib/libc.so.6+0x38f50)
 #5 0x00007f117dea08ec (/usr/lib/libc.so.6+0x878ec)
 #6 0x00007f117de51ea8 raise (/usr/lib/libc.so.6+0x38ea8)
 #7 0x00007f117de3b53d abort (/usr/lib/libc.so.6+0x2253d)
 #8 0x00007f117de3b45c (/usr/lib/libc.so.6+0x2245c)
 #9 0x00007f117de4a9f6 (/usr/lib/libc.so.6+0x319f6)
#10 0x000055d1621313f5 llvm::SmallVectorTemplateCommon<std::pair<mlir::Operation*, circt::fsm::StateOp>, void>::front() /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/SmallVector.h:304:17
#11 0x000055d16212bf8b (anonymous namespace)::CompileFSMVisitor::visit(circt::fsm::StateOp, circt::calyx::SeqOp, circt::fsm::StateOp) /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:196:26
#12 0x000055d16212d57f auto (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)::operator()<circt::calyx::SeqOp>(auto) const /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:44:79
#13 0x000055d16212d5fc llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>& llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>::Case<circt::calyx::SeqOp, (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)&>((anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)&) /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:122:28
#14 0x000055d16212b2d2 Case<circt::calyx::SeqOp, circt::calyx::EnableOp, circt::calyx::IfOp, circt::calyx::WhileOp, (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::<lambda(auto:51)> > /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:46:40
#15 0x000055d16212b2d2 (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp) /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:43:55
#16 0x000055d16212bef9 (anonymous namespace)::CompileFSMVisitor::visit(circt::fsm::StateOp, circt::calyx::SeqOp, circt::fsm::StateOp) /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:188:15
#17 0x000055d16212d57f auto (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)::operator()<circt::calyx::SeqOp>(auto) const /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:44:79
#18 0x000055d16212d5fc llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>& llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>::Case<circt::calyx::SeqOp, (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)&>((anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)&) /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:122:28
#19 0x000055d16212b2d2 Case<circt::calyx::SeqOp, circt::calyx::EnableOp, circt::calyx::IfOp, circt::calyx::WhileOp, (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::<lambda(auto:51)> > /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:46:40
#20 0x000055d16212b2d2 (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp) /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:43:55
#21 0x000055d16212b958 (anonymous namespace)::CompileFSMVisitor::visit(circt::fsm::StateOp, circt::calyx::IfOp, circt::fsm::StateOp)::'lambda'(mlir::Value, llvm::StringRef, bool, mlir::Operation*)::operator()(mlir::Value, llvm::StringRef, bool, mlir::Operation*) const /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:147:15
#22 0x000055d16212bb0e (anonymous namespace)::CompileFSMVisitor::visit(circt::fsm::StateOp, circt::calyx::IfOp, circt::fsm::StateOp) /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:153:13
#23 0x000055d16212dbe3 auto (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)::operator()<circt::calyx::IfOp>(auto) const /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:44:79
#24 0x000055d16212dc60 llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>& llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>::Case<circt::calyx::IfOp, (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)&>((anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)&) /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:122:28
#25 0x000055d16212b320 Case<circt::calyx::IfOp, circt::calyx::WhileOp, (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::<lambda(auto:51)>&> /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:46:40
#26 0x000055d16212b320 Case<circt::calyx::EnableOp, circt::calyx::IfOp, circt::calyx::WhileOp, (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::<lambda(auto:51)>&> /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:47:42
#27 0x000055d16212b320 Case<circt::calyx::SeqOp, circt::calyx::EnableOp, circt::calyx::IfOp, circt::calyx::WhileOp, (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::<lambda(auto:51)> > /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:47:42
#28 0x000055d16212b320 (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp) /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:43:55
#29 0x000055d16212bef9 (anonymous namespace)::CompileFSMVisitor::visit(circt::fsm::StateOp, circt::calyx::SeqOp, circt::fsm::StateOp) /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:188:15
#30 0x000055d16212d57f auto (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)::operator()<circt::calyx::SeqOp>(auto) const /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:44:79
#31 0x000055d16212d5fc llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>& llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>::Case<circt::calyx::SeqOp, (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)&>((anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)&) /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:122:28
#32 0x000055d16212b2d2 Case<circt::calyx::SeqOp, circt::calyx::EnableOp, circt::calyx::IfOp, circt::calyx::WhileOp, (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::<lambda(auto:51)> > /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:46:40
#33 0x000055d16212b2d2 (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp) /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:43:55
#34 0x000055d16212bef9 (anonymous namespace)::CompileFSMVisitor::visit(circt::fsm::StateOp, circt::calyx::SeqOp, circt::fsm::StateOp) /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:188:15
#35 0x000055d16212d57f auto (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)::operator()<circt::calyx::SeqOp>(auto) const /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:44:79
#36 0x000055d16212d5fc llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>& llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>::Case<circt::calyx::SeqOp, (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)&>((anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)&) /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:122:28
#37 0x000055d16212b2d2 Case<circt::calyx::SeqOp, circt::calyx::EnableOp, circt::calyx::IfOp, circt::calyx::WhileOp, (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::<lambda(auto:51)> > /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:46:40
#38 0x000055d16212b2d2 (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp) /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:43:55
#39 0x000055d16212cada (anonymous namespace)::CalyxToFSMPass::runOnOperation() /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:307:13
#40 0x000055d164764cc4 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Pass/Pass.cpp:471:27
#41 0x000055d164764fb0 mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Pass/Pass.cpp:534:15
#42 0x000055d1647660e8 mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&)::operator()(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&) const /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Pass/Pass.cpp:754:47
#43 0x000055d164768e17 mlir::LogicalResult mlir::failableParallelForEach<__gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo>>>, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&)&>(mlir::MLIRContext*, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo>>>, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo>>>, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&)&) /home/xerpi/Desktop/Research/circt/llvm/mlir/include/mlir/IR/Threading.h:46:17
#44 0x000055d1647681df mlir::LogicalResult mlir::failableParallelForEach<std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo>>&, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&)&>(mlir::MLIRContext*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo>>&, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&)&) /home/xerpi/Desktop/Research/circt/llvm/mlir/include/mlir/IR/Threading.h:94:1
#45 0x000055d164766627 mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Pass/Pass.cpp:764:13
#46 0x000055d164765ab9 mlir::detail::OpToOpPassAdaptor::runOnOperation(bool) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Pass/Pass.cpp:658:1
#47 0x000055d164764ca5 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Pass/Pass.cpp:468:28
#48 0x000055d164764fb0 mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Pass/Pass.cpp:534:15
#49 0x000055d164766e06 mlir::PassManager::runPasses(mlir::Operation*, mlir::AnalysisManager) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Pass/Pass.cpp:843:40
#50 0x000055d164766c66 mlir::PassManager::run(mlir::Operation*) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Pass/Pass.cpp:823:69
#51 0x000055d16397c887 performActions(llvm::raw_ostream&, std::shared_ptr<llvm::SourceMgr> const&, mlir::MLIRContext*, mlir::MlirOptMainConfig const&) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:175:13
#52 0x000055d16397ccf5 processBuffer(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, mlir::MlirOptMainConfig const&, mlir::DialectRegistry&, llvm::ThreadPool*) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:221:26
#53 0x000055d16397ce21 mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, mlir::DialectRegistry&, mlir::MlirOptMainConfig const&)::'lambda'(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)::operator()(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&) const /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:262:25
#54 0x000055d16397dcd2 mlir::LogicalResult llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>::callback_fn<mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, mlir::DialectRegistry&, mlir::MlirOptMainConfig const&)::'lambda'(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>(long, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&) /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:45:52
#55 0x000055d1639bae6b llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>::operator()(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&) const /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:68:12
#56 0x000055d1639ba6ff mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Support/ToolUtilities.cpp:28:30
#57 0x000055d16397cfd2 mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, mlir::DialectRegistry&, mlir::MlirOptMainConfig const&) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:265:31
#58 0x000055d16397d8cf mlir::MlirOptMain(int, char**, llvm::StringRef, mlir::DialectRegistry&, bool) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:354:13
#59 0x000055d161ddc13e main /home/xerpi/Desktop/Research/circt/tools/circt-opt/circt-opt.cpp:70:22
#60 0x00007f117de3c790 (/usr/lib/libc.so.6+0x23790)
#61 0x00007f117de3c84a __libc_start_main (/usr/lib/libc.so.6+0x2384a)
#62 0x000055d161ddbec5 _start (../../circt/build/bin/circt-opt+0x119ec5)
Aborted (core dumped)",,,,,,,
4834,"circuit Top : %[[
  {
    ""class"": ""sifive.enterprise.firrtl.MarkDUTAnnotation"",
    ""target"":""~Top|DUTModule""
  },
  {
    ""class"":""firrtl.transforms.DontTouchAnnotation"",
    ""target"":""~Top|Top>memTap""
  },
  {
    ""class"":""sifive.enterprise.grandcentral.MemTapAnnotation"",
    ""source"":""~Top|DUTModule>rf"",
    ""sink"":[
      ""~Top|Top>memTap[0]"",
      ""~Top|Top>memTap[1]"",
      ""~Top|Top>memTap[2]"",
      ""~Top|Top>memTap[3]"",
      ""~Top|Top>memTap[4]"",
      ""~Top|Top>memTap[5]"",
      ""~Top|Top>memTap[6]"",
      ""~Top|Top>memTap[7]""
    ]
  },
  {
    ""class"": ""firrtl.passes.InlineAnnotation"",
    ""target"": ""~Top|DUTModule""
  }
]]
  module DUTModule :
    input clock : Clock
    input reset : Reset
    output io : { flip addr : UInt<3>, flip dataIn : UInt<8>, flip wen : UInt<1>, dataOut : UInt<8>}

    cmem rf : UInt<8> [8]
    infer mport read = rf[io.addr], clock
    io.dataOut <= read
    when io.wen :
      infer mport write = rf[io.addr], clock
      write <= io.dataIn

  module Top :
    input clock : Clock
    input reset : UInt<1>
    output io : { flip addr : UInt<3>, flip dataIn : UInt<8>, flip wen : UInt<1>, dataOut : UInt<8>}

    inst dut of DUTModule
    dut.clock <= clock
    dut.reset <= reset
    wire memTap : UInt<8>[8]
    memTap is invalid
    io.dataOut <= dut.io.dataOut
    dut.io.wen <= io.wen
    dut.io.dataIn <= io.dataIn
    dut.io.addr <= io.addr",,,,,,,,,
4816,,,,,,,,,,
4780,"circuit wut :
   module wut :
     output rwDataOut : UInt<8>

     rwDataOut <= rwDataOut","firtool: /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/UseDefLists.h:190: void mlir::IRObjectWithUseList<mlir::OpOperand>::replaceAllUsesWith(ValueT &&) [OperandType = mlir::OpOperand, ValueT = mlir::Value &]: Assertion `(!newValue || this != OperandType::getUseList(newValue)) && ""cannot RAUW a value with itself""' failed.
PLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.
Stack dump:
0.	Program arguments: ./build/bin/firtool wut.fir
 #0 0x00000000006c71bb llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/will/src/sifive/circt/llvm/llvm/lib/Support/Unix/Signals.inc:602:13
 #1 0x00000000006c5450 llvm::sys::RunSignalHandlers() /home/will/src/sifive/circt/llvm/llvm/lib/Support/Signals.cpp:105:18
 #2 0x00000000006c786d SignalHandler(int) /home/will/src/sifive/circt/llvm/llvm/lib/Support/Unix/Signals.inc:0:3
 #3 0x00007f882063dbf0 __restore_rt (/nix/store/yzjgl0h6a3qh1mby405428f16xww37h0-glibc-2.35-224/lib/libc.so.6+0x3dbf0)
 #4 0x00007f882068abc7 __pthread_kill_implementation (/nix/store/yzjgl0h6a3qh1mby405428f16xww37h0-glibc-2.35-224/lib/libc.so.6+0x8abc7)
 #5 0x00007f882063db46 gsignal (/nix/store/yzjgl0h6a3qh1mby405428f16xww37h0-glibc-2.35-224/lib/libc.so.6+0x3db46)
 #6 0x00007f88206284b5 abort (/nix/store/yzjgl0h6a3qh1mby405428f16xww37h0-glibc-2.35-224/lib/libc.so.6+0x284b5)
 #7 0x00007f88206283d9 _nl_load_domain.cold.0 (/nix/store/yzjgl0h6a3qh1mby405428f16xww37h0-glibc-2.35-224/lib/libc.so.6+0x283d9)
 #8 0x00007f88206367b6 (/nix/store/yzjgl0h6a3qh1mby405428f16xww37h0-glibc-2.35-224/lib/libc.so.6+0x367b6)
 #9 0x0000000000a5476c std::enable_if<!(std::is_convertible<mlir::ValueRange&, mlir::Operation*>::value), void>::type mlir::ResultRange::replaceAllUsesWith<mlir::ValueRange&>(mlir::ValueRange&) /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/ValueRange.h:271:5
#10 0x0000000000a52ec3 mlir::RewriterBase::replaceOp(mlir::Operation*, mlir::ValueRange) /home/will/src/sifive/circt/llvm/mlir/lib/IR/PatternMatch.cpp:275:61
#11 0x0000000000c31cb7 circt::sv::WireOp::canonicalize(circt::sv::WireOp, mlir::PatternRewriter&) /home/will/src/sifive/circt/lib/Dialect/SV/SVOps.cpp:1460:18
#12 0x0000000000e0ccb7 mlir::PatternApplicator::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&, llvm::function_ref<bool (mlir::Pattern const&)>, llvm::function_ref<void (mlir::Pattern const&)>, llvm::function_ref<mlir::LogicalResult (mlir::Pattern const&)>) /home/will/src/sifive/circt/llvm/mlir/lib/Rewrite/PatternApplicator.cpp:200:25
#13 0x0000000000dd93ed (anonymous namespace)::GreedyPatternRewriteDriver::processWorklist() /home/will/src/sifive/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:229:19
#14 0x0000000000dd702d (anonymous namespace)::RegionPatternRewriteDriver::simplify() && /home/will/src/sifive/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:458:15
#15 0x0000000000dd702d mlir::applyPatternsAndFoldGreedily(mlir::Region&, mlir::FrozenRewritePatternSet const&, mlir::GreedyRewriteConfig) /home/will/src/sifive/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:487:47
#16 0x0000000000a66148 mlir::LogicalResult::failed() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33
#17 0x0000000000a66148 mlir::applyPatternsAndFoldGreedily(mlir::Operation*, mlir::FrozenRewritePatternSet const&, mlir::GreedyRewriteConfig) /home/will/src/sifive/circt/llvm/mlir/include/mlir/Transforms/GreedyPatternRewriteDriver.h:115:70
#18 0x0000000000a66148 (anonymous namespace)::Canonicalizer::runOnOperation() /home/will/src/sifive/circt/llvm/mlir/lib/Transforms/Canonicalizer.cpp:61:9
#19 0x0000000000ee9829 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:0:11
#20 0x0000000000ee9e61 mlir::LogicalResult::failed() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33
#21 0x0000000000ee9e61 mlir::failed(mlir::LogicalResult) /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:72:58
#22 0x0000000000ee9e61 mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:534:9
#23 0x0000000000eeb518 std::vector<std::atomic<bool>, std::allocator<std::atomic<bool> > >::size() const /nix/store/z1yw9cw97bcdfmxz5wk7j1bycw42r1mw-gcc-11.3.0/include/c++/11.3.0/bits/stl_vector.h:919:66
#24 0x0000000000eeb518 std::vector<std::atomic<bool>, std::allocator<std::atomic<bool> > >::operator[](unsigned long) /nix/store/z1yw9cw97bcdfmxz5wk7j1bycw42r1mw-gcc-11.3.0/include/c++/11.3.0/bits/stl_vector.h:1045:2
#25 0x0000000000eeb518 mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_14::operator()(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&) const /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:759:5
#26 0x0000000000eeb518 mlir::LogicalResult mlir::failableParallelForEach<__gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_14&>(mlir::MLIRContext*, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_14&) /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/Threading.h:46:18
#27 0x0000000000eeb518 mlir::LogicalResult mlir::failableParallelForEach<std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> >&, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_14&>(mlir::MLIRContext*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> >&, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_14&) /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/Threading.h:92:10
#28 0x0000000000eeb518 mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:764:14
#29 0x0000000000ee9865 mlir::detail::OpToOpPassAdaptor::runOnOperation(bool) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:0:5
#30 0x0000000000ee9865 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:468:14
#31 0x0000000000eec3a3 mlir::LogicalResult::failed() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33
#32 0x0000000000eec3a3 mlir::failed(mlir::LogicalResult) /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:72:58
#33 0x0000000000eec3a3 mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:534:9
#34 0x0000000000eec3a3 mlir::PassManager::runPasses(mlir::Operation*, mlir::AnalysisManager) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:843:10
#35 0x0000000000eec3a3 mlir::PassManager::run(mlir::Operation*) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:823:60
#36 0x000000000061a57b mlir::LogicalResult::failed() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33
#37 0x000000000061a57b mlir::failed(mlir::LogicalResult) /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:72:58
#38 0x000000000061a57b processBuffer(mlir::MLIRContext&, mlir::TimingScope&, llvm::SourceMgr&, std::optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile> > >&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:856:7
#39 0x00000000006182bf processInputSplit(mlir::MLIRContext&, mlir::TimingScope&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, std::optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile> > >&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:952:12
#40 0x0000000000617f42 processInput(mlir::MLIRContext&, mlir::TimingScope&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, std::optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile> > >&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:968:12
#41 0x0000000000617f42 executeFirtool(mlir::MLIRContext&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:1058:14
#42 0x00000000006179f6 mlir::LogicalResult::failed() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33
#43 0x00000000006179f6 mlir::failed(mlir::LogicalResult) /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:72:58
#44 0x00000000006179f6 main /home/will/src/sifive/circt/tools/firtool/firtool.cpp:1122:8
#45 0x00007f882062924e __libc_start_call_main (/nix/store/yzjgl0h6a3qh1mby405428f16xww37h0-glibc-2.35-224/lib/libc.so.6+0x2924e)
#46 0x00007f8820629309 __libc_start_main@GLIBC_2.2.5 (/nix/store/yzjgl0h6a3qh1mby405428f16xww37h0-glibc-2.35-224/lib/libc.so.6+0x29309)
#47 0x0000000000617825 _start (./build/bin/firtool+0x617825)
zsh: IOT instruction (core dumped)  ./build/bin/firtool wut.fir","// -----// IR Dump Before Canonicalizer (canonicalize) //----- //
hw.module @wut() -> (rwDataOut: i8) {
  %.rwDataOut.output = sv.wire : !hw.inout<i8>
  %0 = sv.read_inout %.rwDataOut.output : !hw.inout<i8>
  sv.assign %.rwDataOut.output, %0 : i8
  hw.output %0 : i8
}",,,,,,,
4771,"circuit Foo :
  module Foo :
    output d : { a: UInt<2>, b: Analog<1>}
    input c : UInt<1>
    d is invalid
    when c :
      inst b of Bar
      attach(d.b, b.b.b[c])
    else :
      inst b2 of Bar
      attach(d.b, b2.b.b[c])

  extmodule Bar :
    output b : { a : UInt<2>, b : Analog<1>[2]}","analog.fir:11:11: error: operand isn't an inout type
      d.b <- b2.b.b[c]
          ^
analog.fir:11:11: note: see current operation: ""firrtl.attach""(%1, %19, %11) : (!firrtl.analog<1>, !firrtl.analog<1>, !firrtl.analog<1>) -> ()
analog.fir:11:11: error: 'firrtl.attach' op LowerToHW couldn't handle this operation
      d.b <- b2.b.b[c]
          ^
analog.fir:11:11: note: see current operation: ""firrtl.attach""(%1, %19, %11) : (!firrtl.analog<1>, !firrtl.analog<1>, !firrtl.analog<1>) -> ()",,,,,,,,
4770,hw.module.extern @parameter (),"verilog-error.mlir:4:1: error: name ""parameter"" is not allowed in Verilog output
hw.module.extern @parameter ()
^
verilog-error.mlir:4:1: note: see current operation: 
""hw.module.extern""() ({
}) {argLocs = [], argNames = [], comment = """", function_type = () -> (), parameters = [], resultLocs = [], resultNames = [], sym_name = ""parameter""} : () -> ()
// Generated by CIRCT 1.34.0g20230304_3ddf879
// external module parameter",,,,,,,,
4753,"circuit Foo:
  module Foo:
    input a: UInt<8>[3]
    output b: UInt<8>

    b <= a[UInt<99>(300)]","Foo.fir:6:12: error: out of range index '300' in vector type '!firrtl.vector<uint<8>, 3>'
    b <= a[UInt<99>(300)]
           ^
LLVM ERROR: Failed to infer result type(s).
PLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.
Stack dump:
0.	Program arguments: firtool Foo.fir
Stack dump without symbol names (ensure you have llvm-symbolizer in your PATH or set the environment var `LLVM_SYMBOLIZER_PATH` to point to it):
0  firtool                  0x00000001039cf21d llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) + 61
1  firtool                  0x00000001039cf79b PrintStackTraceSignalHandler(void*) + 27
2  firtool                  0x00000001039cd566 llvm::sys::RunSignalHandlers() + 134
3  firtool                  0x00000001039d14cf SignalHandler(int) + 223
4  libsystem_platform.dylib 0x00007ff80f497dfd _sigtramp + 29
5  firtool                  0x00000001037856e5 std::__1::__libcpp_deallocate(void*, unsigned long, unsigned long) + 85
6  libsystem_c.dylib        0x00007ff80f3cdd24 abort + 123
7  firtool                  0x000000010389f2d4 llvm::report_fatal_error(llvm::Twine const&, bool) + 388
8  firtool                  0x000000010389f145 llvm::report_fatal_error(char const*, bool) + 53
9  firtool                  0x000000010479c065 circt::firrtl::SubindexOp::build(mlir::OpBuilder&, mlir::OperationState&, mlir::Value, unsigned int) + 533
10 firtool                  0x0000000103ed526c circt::firrtl::SubindexOp mlir::OpBuilder::create<circt::firrtl::SubindexOp, mlir::detail::TypedValue<circt::firrtl::FIRRTLBaseType>, long long>(mlir::Location, mlir::detail::TypedValue<circt::firrtl::FIRRTLBaseType>&&, long long&&) + 220
11 firtool                  0x0000000103ed4fd1 circt::firrtl::SubindexOp mlir::ImplicitLocOpBuilder::create<circt::firrtl::SubindexOp, mlir::detail::TypedValue<circt::firrtl::FIRRTLBaseType>, long long>(mlir::detail::TypedValue<circt::firrtl::FIRRTLBaseType>&&, long long&&) + 81",,,,,,,,
4586,"circuit Top : %[[
  {
    ""class"":""sifive.enterprise.firrtl.NestedPrefixModulesAnnotation"",
    ""target"":""~Top|Foo"",
    ""prefix"":""A_"",
    ""inclusive"":true
  },
  {
    ""class"":""sifive.enterprise.firrtl.NestedPrefixModulesAnnotation"",
    ""target"":""~Top|Foo_1"",
    ""prefix"":""B_"",
    ""inclusive"":true
  },
  {
    ""class"": ""firrtl.transforms.DontTouchAnnotation"",
    ""target"": ""~Top|Foo>in""
  },
  {
    ""class"": ""firrtl.transforms.DontTouchAnnotation"",
    ""target"": ""~Top|Foo_1>in""
  }
]]
  module Foo :
    input in : UInt<8>

  module Foo_1 :
    input in : UInt<8>

  module Top :
    input in : UInt<8>

    inst f1 of Foo
    inst f2 of Foo_1
    f1.in <= in
    f2.in <= in","module A_Foo(
  input [7:0] in);

endmodule

module Top(
  input [7:0] in);

  A_Foo f1 (
    .in (in)
  );
  A_Foo f2 (
    .in (in)
  );
endmodule","module A_Foo(
  input [7:0] in);

endmodule

module B_Foo_1(
  input [7:0] in);

endmodule

module Top(
  input [7:0] in);

  A_Foo f1 (
    .in (in)
  );
  B_Foo_1 f2 (
    .in (in)
  );
endmodule",,,,,,,
4354,"firrtl.circuit ""ForceNameTop"" {
  firrtl.hierpath private @nla_1 [@ForceNameTop::@sym_foo, @ForceNameSubmodule]
  firrtl.hierpath private @nla_2 [@ForceNameTop::@sym_bar, @ForceNameSubmodule]
  firrtl.module private @ForceNameSubmodule() attributes {annotations = [
    {circt.nonlocal = @nla_1,
     class = ""chisel3.util.experimental.ForceNameAnnotation"", name = ""Foo""},
    {circt.nonlocal = @nla_2,
     class = ""chisel3.util.experimental.ForceNameAnnotation"", name = ""Foo""}
  ]} {}
  firrtl.module @ForceNameTop() {
    firrtl.instance Foo @ForceNameSubmodule()
    firrtl.instance foo sym @sym_foo @ForceNameSubmodule()
    firrtl.instance bar sym @sym_bar @ForceNameSubmodule()
  }
}","module {
  hw.module private @ForceNameSubmodule() {
    hw.output
  }
  hw.module @ForceNameTop() {
    hw.instance ""Foo"" @ForceNameSubmodule() -> ()
    hw.instance ""foo"" sym @sym_foo @ForceNameSubmodule() -> () {hw.verilogName = ""Foo""}
    hw.instance ""bar"" sym @sym_bar @ForceNameSubmodule() -> () {hw.verilogName = ""Foo""}
    hw.output
  }
}","// Generated by CIRCT unknown git version
module ForceNameSubmodule();
endmodule

module ForceNameTop();
  ForceNameSubmodule Foo_0 ();
  ForceNameSubmodule Foo ();
  ForceNameSubmodule Foo_1 ();
endmodule",,,,,,,
4097,"circuit Top :
  extmodule DataTap_2 :
    output _2 : UInt<1>
    output _1 : UInt<1>
    output _0 : Clock
    defname = DataTap_2

  module Wrapper :
    input clock : Clock
    input reset : Reset
    input in : UInt<1>

    node _T = asUInt(reset)
    node _T_1 = eq(_T, UInt<1>(""h0""))
    when _T_1 :
      node _T_2 = eq(in, UInt<1>(""h0""))
      when _T_2 :
        printf(clock, UInt<1>(""h1""), ""Assertion failed: hello\n    at AssertInView.scala:24 assert(in, \""hello\"")\n"") : printf
      assert(clock, in, UInt<1>(""h1""), """") : assert


  module MyView_companion :

    wire _WIRE : UInt<1>
    _WIRE <= UInt<1>(""h0"")
    wire clk : Clock
    wire rst : UInt<1>
    wire cond : UInt<1>
    inst DataTap_2 of DataTap_2
    DataTap_2._0 is invalid
    DataTap_2._1 is invalid
    DataTap_2._2 is invalid
    clk <= DataTap_2._0
    rst <= DataTap_2._1
    cond <= DataTap_2._2
    inst wrapper of Wrapper
    wrapper.clock <= clk
    wrapper.reset <= rst
    wrapper.in <= cond

  module DUT :
    input clock : Clock
    input reset : Reset
    input in : UInt<1>

    wire w : UInt<1>
    w <= in
    inst MyView_companion of MyView_companion

  module Top :
    input clock : Clock
    input reset : UInt<1>
    input in : UInt<1>

    inst dut of DUT
    dut.clock <= clock
    dut.reset <= reset
    dut.in <= in","[
  {
    ""class"":""sifive.enterprise.grandcentral.DataTapsAnnotation"",
    ""blackBox"":""~Top|DataTap_2"",
    ""keys"":[
      {
        ""class"":""sifive.enterprise.grandcentral.ReferenceDataTapKey"",
        ""source"":""~Top|Top/dut:DUT>clock"",
        ""portName"":""~Top|DataTap_2>_0""
      },
      {
        ""class"":""sifive.enterprise.grandcentral.ReferenceDataTapKey"",
        ""source"":""~Top|Top/dut:DUT>reset"",
        ""portName"":""~Top|DataTap_2>_1""
      },
      {
        ""class"":""sifive.enterprise.grandcentral.ReferenceDataTapKey"",
        ""source"":""~Top|Top/dut:DUT>w"",
        ""portName"":""~Top|DataTap_2>_2""
      }
    ]
  },
  {
    ""class"":""sifive.enterprise.grandcentral.GrandCentralView$SerializedViewAnnotation"",
    ""name"":""MyView"",
    ""companion"":""~Top|MyView_companion"",
    ""parent"":""~Top|DUT"",
    ""view"":""{\""class\"":\""sifive.enterprise.grandcentral.AugmentedBundleType\"",\""defName\"":\""MyInterface\"",\""elements\"":[{\""name\"":\""ground\"",\""description\"":\""a ground type port\"",\""tpe\"":{\""class\"":\""sifive.enterprise.grandcentral.AugmentedGroundType\"",\""ref\"":{\""circuit\"":\""Top\"",\""module\"":\""Top\"",\""path\"":[{\""_1\"":{\""class\"":\""firrtl.annotations.TargetToken$Instance\"",\""value\"":\""dut\""},\""_2\"":{\""class\"":\""firrtl.annotations.TargetToken$OfModule\"",\""value\"":\""DUT\""}}],\""ref\"":\""w\"",\""component\"":[]},\""tpe\"":{\""class\"":\""sifive.enterprise.grandcentral.GrandCentralView$UnknownGroundType$\""}}}]}""
  },
  {
    ""class"":""sifive.enterprise.firrtl.MarkDUTAnnotation"",
    ""target"":""Top.DUT""
  },
  {
    ""class"":""sifive.enterprise.grandcentral.ExtractGrandCentralAnnotation"",
    ""directory"":""gct"",
    ""filename"":""bindings.sv""
  }
]","// Generated by CIRCT unknown git version
// Standard header to adapt well known macros to our needs.

// Users can define 'ASSERT_VERBOSE_COND' to add an extra gate to assert error printing.
`ifdef ASSERT_VERBOSE_COND
  `define ASSERT_VERBOSE_COND_ (`ASSERT_VERBOSE_COND)
`else  // ASSERT_VERBOSE_COND
  `define ASSERT_VERBOSE_COND_ 1
`endif // ASSERT_VERBOSE_COND

// Users can define 'STOP_COND' to add an extra gate to stop conditions.
`ifdef STOP_COND
  `define STOP_COND_ (`STOP_COND)
`else  // STOP_COND
  `define STOP_COND_ 1
`endif // STOP_COND

// VCS coverage exclude_file
module Wrapper_assert(
  input in,
        reset,
        clock);

  `ifndef SYNTHESIS
    always @(posedge clock) begin
      if (~reset & ~in) begin
        if (`ASSERT_VERBOSE_COND_)
          $error(""Assertion failed: hello\n    at AssertInView.scala:24 assert(in, \""hello\"")\n"");
        if (`STOP_COND_)
          $fatal;
      end
    end // always @(posedge)
  `endif // not def SYNTHESIS
endmodule

module DUT(
  input clock,
        reset,
        in);

  wire w = in;
  /* This instance is elsewhere emitted as a bind statement.
    MyView_companion MyView_companion ();
  */
endmodule

module Top(
  input clock,
        reset,
        in);

  DUT dut (
    .clock (clock),
    .reset (reset),
    .in    (in)
  );
endmodule


// ----- 8< ----- FILE ""gct/DataTap_2_impl_0.sv"" ----- 8< -----

// Generated by CIRCT unknown git version
// VCS coverage exclude_file
module DataTap_2_impl_0(
  output _2,
         _1,
         _0);

  assign _2 = DUT.w;
  assign _1 = DUT.reset;
  assign _0 = DUT.clock;
endmodule


// ----- 8< ----- FILE ""gct/MyView_companion.sv"" ----- 8< -----

// Generated by CIRCT unknown git version
// Standard header to adapt well known macros to our needs.

// Users can define 'ASSERT_VERBOSE_COND' to add an extra gate to assert error printing.
`ifdef ASSERT_VERBOSE_COND
  `define ASSERT_VERBOSE_COND_ (`ASSERT_VERBOSE_COND)
`else  // ASSERT_VERBOSE_COND
  `define ASSERT_VERBOSE_COND_ 1
`endif // ASSERT_VERBOSE_COND

// Users can define 'STOP_COND' to add an extra gate to stop conditions.
`ifdef STOP_COND
  `define STOP_COND_ (`STOP_COND)
`else  // STOP_COND
  `define STOP_COND_ 1
`endif // STOP_COND

// VCS coverage exclude_file
module MyView_companion();
  wire _DataTap_2__2;
  wire _DataTap_2__1;
  wire _DataTap_2__0;
  MyInterface MyView();
  `ifndef SYNTHESIS
    always @(posedge _DataTap_2__0) begin
      if (~_DataTap_2__1 & ~_DataTap_2__2) begin
        if (`ASSERT_VERBOSE_COND_)
          $error(""Assertion failed: hello\n    at AssertInView.scala:24 assert(in, \""hello\"")\n"");
        if (`STOP_COND_)
          $fatal;
      end
    end // always @(posedge)
  `endif // not def SYNTHESIS
  assign MyView.ground = DUT.w;
  DataTap_2_impl_0 DataTap_2 (
    ._2 (_DataTap_2__2),
    ._1 (_DataTap_2__1),
    ._0 (_DataTap_2__0)
  );
  /* This instance is elsewhere emitted as a bind statement.
    Wrapper_assert Wrapper_assert (
      .in    (_DataTap_2__2),
      .reset (_DataTap_2__1),
      .clock (_DataTap_2__0)
    );
  */
endmodule


// ----- 8< ----- FILE ""bindings.sv"" ----- 8< -----

// Generated by CIRCT unknown git version
bind DUT MyView_companion MyView_companion ();

// ----- 8< ----- FILE ""gct/MyInterface.sv"" ----- 8< -----

// Generated by CIRCT unknown git version
// VCS coverage exclude_file
interface MyInterface;
  // a ground type port
  logic ground;
endinterface


// ----- 8< ----- FILE ""bindfile"" ----- 8< -----

// Standard header to adapt well known macros to our needs.

// Users can define 'ASSERT_VERBOSE_COND' to add an extra gate to assert error printing.
`ifdef ASSERT_VERBOSE_COND
  `define ASSERT_VERBOSE_COND_ (`ASSERT_VERBOSE_COND)
`else  // ASSERT_VERBOSE_COND
  `define ASSERT_VERBOSE_COND_ 1
`endif // ASSERT_VERBOSE_COND

// Users can define 'STOP_COND' to add an extra gate to stop conditions.
`ifdef STOP_COND
  `define STOP_COND_ (`STOP_COND)
`else  // STOP_COND
  `define STOP_COND_ 1
`endif // STOP_COND

bind MyView_companion Wrapper_assert Wrapper_assert (
  .in    (_DataTap_2__2),
  .reset (_DataTap_2__1),
  .clock (_DataTap_2__0)
);",,,,,,,
3810,,,,,,,,,,
3768,"hw.type_scope @fsm_enum_typedecls {
    hw.typedecl @M2_state_t : !hw.enum<A, B>
    hw.typedecl @M1_state_t : !hw.enum<A, B>
  }","typedef enum {A, B} M2_state_t;
typedef enum {A, B} M1_state_t;","typedef enum {M2_state_A, M2_state_B} M2_state_t;
typedef enum {M1_state_A, M1_state_B} M1_state_t;",,,,,,,
3494,"circuit Top :
  module Bar :
    input clock : Clock
    input reset : Reset

    wire w : UInt<1>
    w <= UInt<1>(""h0"")

  module MyView_companion :

    skip

  module Foo :
    input clock : Clock
    input reset : Reset

    inst bar of Bar
    bar.clock <= clock
    bar.reset <= reset
    inst MyView_companion of MyView_companion

  module Bar_1 :
    input clock : Clock
    input reset : Reset

    wire w : UInt<1>
    w <= UInt<1>(""h0"")

  module MyView_companion_0 :

    skip

  module Foo_1 :
    input clock : Clock
    input reset : Reset

    inst bar of Bar_1
    bar.clock <= clock
    bar.reset <= reset
    inst MyView_companion_0 of MyView_companion_0

  module Top :
    input clock : Clock
    input reset : UInt<1>

    inst foo1 of Foo
    foo1.clock <= clock
    foo1.reset <= reset
    inst foo2 of Foo_1
    foo2.clock <= clock
    foo2.reset <= reset","[
  {
    ""class"": ""sifive.enterprise.grandcentral.ViewAnnotation"",
    ""name"": ""MyView"",
    ""companion"": ""~Top|MyView_companion"",
    ""parent"": ""~Top|Foo"",
    ""view"": {
      ""class"": ""sifive.enterprise.grandcentral.AugmentedBundleType"",
      ""defName"": ""MyInterface"",
      ""elements"": [
        {
          ""name"": ""w"",
          ""tpe"": {
            ""class"": ""sifive.enterprise.grandcentral.AugmentedGroundType"",
            ""ref"": {
              ""circuit"": ""Top"",
              ""module"": ""Top"",
              ""path"": [
                {
                  ""_1"": {
                    ""class"": ""firrtl.annotations.TargetToken$Instance"",
                    ""value"": ""foo1""
                  },
                  ""_2"": {
                    ""class"": ""firrtl.annotations.TargetToken$OfModule"",
                    ""value"": ""Foo""
                  }
                },
                {
                  ""_1"": {
                    ""class"": ""firrtl.annotations.TargetToken$Instance"",
                    ""value"": ""bar""
                  },
                  ""_2"": {
                    ""class"": ""firrtl.annotations.TargetToken$OfModule"",
                    ""value"": ""Bar""
                  }
                }
              ],
              ""ref"": ""w"",
              ""component"": []
            },
            ""tpe"": {
              ""class"": ""sifive.enterprise.grandcentral.GrandCentralView$UnknownGroundType$""
            }
          }
        }
      ]
    }
  },
  {
    ""class"": ""sifive.enterprise.grandcentral.ViewAnnotation"",
    ""name"": ""MyView"",
    ""companion"": ""~Top|MyView_companion_0"",
    ""parent"": ""~Top|Foo_1"",
    ""view"": {
      ""class"": ""sifive.enterprise.grandcentral.AugmentedBundleType"",
      ""defName"": ""MyInterface"",
      ""elements"": [
        {
          ""name"": ""w"",
          ""tpe"": {
            ""class"": ""sifive.enterprise.grandcentral.AugmentedGroundType"",
            ""ref"": {
              ""circuit"": ""Top"",
              ""module"": ""Top"",
              ""path"": [
                {
                  ""_1"": {
                    ""class"": ""firrtl.annotations.TargetToken$Instance"",
                    ""value"": ""foo2""
                  },
                  ""_2"": {
                    ""class"": ""firrtl.annotations.TargetToken$OfModule"",
                    ""value"": ""Foo_1""
                  }
                },
                {
                  ""_1"": {
                    ""class"": ""firrtl.annotations.TargetToken$Instance"",
                    ""value"": ""bar""
                  },
                  ""_2"": {
                    ""class"": ""firrtl.annotations.TargetToken$OfModule"",
                    ""value"": ""Bar_1""
                  }
                }
              ],
              ""ref"": ""w"",
              ""component"": []
            },
            ""tpe"": {
              ""class"": ""sifive.enterprise.grandcentral.GrandCentralView$UnknownGroundType$""
            }
          }
        }
      ]
    }
  }
]","firrtl/Top.fir:13:10: error: 'firrtl.module' op is marked as a GrandCentral 'parent', but it is instantiated more than once
  module Foo :
         ^
firrtl/Top.fir:13:10: note: see current operation: ""firrtl.module""() ({
^bb0(%arg0: !firrtl.clock, %arg1: !firrtl.uint<1>):
  %0:2 = ""firrtl.instance""() {annotations = [], inner_sym = #firrtl<""innerSym@bar"">, moduleName = @Bar, name = ""bar"", nameKind = #firrtl<""name_kind droppable_name"">, portAnnotations = [[], []], portDirections = 0 : i2, portNames = [""clock"", ""reset""]} : () -> (!firrtl.clock, !firrtl.uint<1>)
  ""firrtl.strictconnect""(%0#0, %arg0) : (!firrtl.clock, !firrtl.clock) -> ()
  ""firrtl.strictconnect""(%0#1, %arg1) : (!firrtl.uint<1>, !firrtl.uint<1>) -> ()
  ""firrtl.instance""() {annotations = [], inner_sym = #firrtl<""innerSym@MyView_companion"">, moduleName = @MyView_companion, name = ""MyView_companion"", nameKind = #firrtl<""name_kind droppable_name"">, portAnnotations = [], portDirections = 0 : i0, portNames = []} : () -> ()
}) {annotations = [{circt.nonlocal = @nla_3, class = ""sifive.enterprise.grandcentral.ViewAnnotation.parent"", id = 2 : i64, name = ""MyView"", type = ""parent""}, {circt.nonlocal = @nla_4, class = ""sifive.enterprise.grandcentral.ViewAnnotation.parent"", id = 0 : i64, name = ""MyView"", type = ""parent""}], portAnnotations = [[], []], portDirections = 0 : i2, portNames = [""clock"", ""reset""], portSyms = ["""", """"], portTypes = [!firrtl.clock, !firrtl.uint<1>], sym_name = ""Foo"", sym_visibility = ""private""} : () -> ()
firrtl/Top.fir:49:5: note: parent is instantiated here
    inst foo2 of Foo_1
    ^
firrtl/Top.fir:46:5: note: parent is instantiated here
    inst foo1 of Foo
    ^
firrtl/Top.fir:13:10: error: 'firrtl.module' op is marked as a GrandCentral 'parent', but it is instantiated more than once
  module Foo :
         ^
firrtl/Top.fir:13:10: note: see current operation: ""firrtl.module""() ({
^bb0(%arg0: !firrtl.clock, %arg1: !firrtl.uint<1>):
  %0:2 = ""firrtl.instance""() {annotations = [], inner_sym = #firrtl<""innerSym@bar"">, moduleName = @Bar, name = ""bar"", nameKind = #firrtl<""name_kind droppable_name"">, portAnnotations = [[], []], portDirections = 0 : i2, portNames = [""clock"", ""reset""]} : () -> (!firrtl.clock, !firrtl.uint<1>)
  ""firrtl.strictconnect""(%0#0, %arg0) : (!firrtl.clock, !firrtl.clock) -> ()
  ""firrtl.strictconnect""(%0#1, %arg1) : (!firrtl.uint<1>, !firrtl.uint<1>) -> ()
  ""firrtl.instance""() {annotations = [], inner_sym = #firrtl<""innerSym@MyView_companion"">, moduleName = @MyView_companion, name = ""MyView_companion"", nameKind = #firrtl<""name_kind droppable_name"">, portAnnotations = [], portDirections = 0 : i0, portNames = []} : () -> ()
}) {annotations = [{circt.nonlocal = @nla_3, class = ""sifive.enterprise.grandcentral.ViewAnnotation.parent"", id = 2 : i64, name = ""MyView"", type = ""parent""}, {circt.nonlocal = @nla_4, class = ""sifive.enterprise.grandcentral.ViewAnnotation.parent"", id = 0 : i64, name = ""MyView"", type = ""parent""}], portAnnotations = [[], []], portDirections = 0 : i2, portNames = [""clock"", ""reset""], portSyms = ["""", """"], portTypes = [!firrtl.clock, !firrtl.uint<1>], sym_name = ""Foo"", sym_visibility = ""private""} : () -> ()
firrtl/Top.fir:49:5: note: parent is instantiated here
    inst foo2 of Foo_1
    ^
firrtl/Top.fir:46:5: note: parent is instantiated here
    inst foo1 of Foo
    ^
firrtl/Top.fir:1:1: error: 'firrtl.circuit' op contains a 'companion' with id '2', but does not contain a GrandCentral 'parent' with the same id
circuit Top :
^",,,,,,,
3454,"hw.module private @Foo() -> (){
    sv.initial {
      %param_x = sv.localparam : i42 { value = 11: i42 }
    }
}","module Foo();
  initial     
    localparam [41:0] param_x = 42'd11; 

endmodule","initial begin 
    localparam [41:0] param_x = 42'd11;
  end",,,,,,,
3268,"func.func @external_mem(%mem : memref<4xi32>) {
  return
}

func.func @normal_mem() {
  %mem = memref.alloc() : memref<4xi32>
  func.call @external_mem(%mem) : (memref<4xi32>) -> ()
  return
}","handshake.func @external_mem(%arg0: memref<4xi32>, %arg1: none, ...) -> none attributes {argNames = [""in0"", ""inCtrl""], resNames = [""outCtrl""]} {
  extmemory[ld = 0, st = 0] (%arg0 : memref<4xi32>) () {id = 0 : i32} : () -> ()
  return %arg1 : none
 }
handshake.func @normal_mem(%arg0: none, ...) -> none attributes {argNames = [""inCtrl""], resNames = [""outCtrl""]} {
  %0:2 = fork [2] %arg0 : none
  %1 = memref.alloc() : memref<4xi32>
  %2 = instance @external_mem(%1, %0#0) : (memref<4xi32>, none) -> none
  sink %2 : none
  return %0#1 : none
}",,,,,,,,
3240,"circuit Top :
  module Submodule :
    input clock : Clock
    input reset : Reset
    input in : UInt<1>
    output out : UInt<1>

    wire _w : UInt<1> 
    _w <= in 
    out <= _w 

  module Submodule_1 :
    input clock : Clock
    input reset : Reset
    input in : UInt<1>
    output out : UInt<1>

    wire _w : UInt<1> 
    _w <= in 
    out <= _w 

  module MyView_companion :

    wire _WIRE : UInt<1>
    _WIRE <= UInt<1>(""h0"")

  module Top :
    input clock : Clock
    input reset : UInt<1>
    input in : UInt<1>
    output out : UInt<1>

    inst sub1 of Submodule 
    sub1.clock <= clock
    sub1.reset <= reset
    inst sub2 of Submodule_1 
    sub2.clock <= clock
    sub2.reset <= reset
    sub1.in <= in 
    sub2.in <= in 
    node _out_T = xor(sub1.out, sub2.out) 
    out <= _out_T 
    inst MyView_companion of MyView_companion","[
  {
    ""class"":""firrtl.transforms.DontTouchAnnotation"",
    ""target"":""~Top|MyView_companion>_WIRE""
  },
  {
    ""class"":""sifive.enterprise.grandcentral.GrandCentralView$SerializedViewAnnotation"",
    ""name"":""MyView"",
    ""companion"":""~Top|MyView_companion"",
    ""parent"":""~Top|Top"",
    ""view"":""{\""class\"":\""sifive.enterprise.grandcentral.AugmentedBundleType\"",\""defName\"":\""MyInterface\"",\""elements\"":[{\""name\"":\""tap1\"",\""tpe\"":{\""class\"":\""sifive.enterprise.grandcentral.AugmentedGroundType\"",\""ref\"":{\""circuit\"":\""Top\"",\""module\"":\""Top\"",\""path\"":[{\""_1\"":{\""class\"":\""firrtl.annotations.TargetToken$Instance\"",\""value\"":\""sub1\""},\""_2\"":{\""class\"":\""firrtl.annotations.TargetToken$OfModule\"",\""value\"":\""Submodule\""}}],\""ref\"":\""_w\"",\""component\"":[]},\""tpe\"":{\""class\"":\""sifive.enterprise.grandcentral.GrandCentralView$UnknownGroundType$\""}}}]}""
  },
  {
    ""class"":""firrtl.transforms.NoDedupAnnotation"",
    ""target"":""~Top|MyView_companion""
  },
  {
    ""class"":""sifive.enterprise.grandcentral.ExtractGrandCentralAnnotation"",
    ""directory"":""builds/gct-tests/DedupOneTap/firrtl/gct"",
    ""filename"":""builds/gct-tests/DedupOneTap/firrtl/bindings.sv""
  },
  {
    ""class"":""sifive.enterprise.grandcentral.GrandCentralHierarchyFileAnnotation"",
    ""filename"":""builds/gct-tests/DedupOneTap/firrtl/gct/gct.yaml""
  },
  {
    ""class"":""firrtl.stage.RunFirrtlTransformAnnotation"",
    ""transform"":""sifive.enterprise.grandcentral.GrandCentralTransform""
  },
  {
    ""class"":""firrtl.stage.RunFirrtlTransformAnnotation"",
    ""transform"":""sifive.enterprise.firrtl.ExtractTestCodeTransform""
  }
]","module Submodule(
  input  in,
  output out);

  wire _gctTap;

  assign _gctTap = in;
  assign out = in;
endmodule

module Submodule_1(
  input  in,
  output out);

  assign out = in;
endmodule

module Top(
  input  clock,
         reset,
         in,
  output out);

  wire _sub2_out;
  wire _sub1_out;

  // This interface is elsewhere emitted as a bind statement.
  // MyInterface MyView();
  Submodule sub1 (
    .in  (in),
    .out (_sub1_out)
  );
  Submodule_1 sub2 (
    .in  (in),
    .out (_sub2_out)
  );
  /* This instance is elsewhere emitted as a bind statement.
    MyView_companion MyView_companion ();
  */
  assign out = _sub1_out ^ _sub2_out;
endmodule",,,,,,,
3105,,,,,,,,,,
3104,,,,,,,,,,
3090,,,,,,,,,,
3033,"circuit Bar:
  module X:
    input a: UInt<1>
    output b: UInt<1>

    b <= not(a)
  module Y:
    input a: UInt<1>
    output b: UInt<1>

    b <= not(a)
  module Bar:
    input a: UInt<1>
    output b: UInt<1>

    inst y of Y
    inst x of X

    x.a <= a
    y.a <= a
    b <= xor(x.b, y.b)","module Y(
  input  a,
  output b);

  assign b = ~a;
endmodule

module Bar(
  input  a,
  output b);

  wire _x_b;
  wire _y_b;

  Y y (
    .a (a),
    .b (_y_b)
  );
  Y x (
    .a (a),
    .b (_x_b)
  );
  assign b = _x_b ^ _y_b;
endmodule","module X(
  input   a,
  output  b
);
  assign b = ~a;
endmodule
module Bar(
  input   a,
  output  b
);
  wire  y_a;
  wire  y_b;
  wire  x_a;
  wire  x_b;
  X y (
    .a(y_a),
    .b(y_b)
  );
  X x (
    .a(x_a),
    .b(x_b)
  );
  assign b = x_b ^ y_b;
  assign y_a = a;
  assign x_a = a;
endmodule",,,,,,,
2888,"circuit Foo: %[[
  {
    ""class"":""sifive.enterprise.firrtl.NestedPrefixModulesAnnotation"",
    ""prefix"":""prefix1_"",
    ""inclusive"":true,
    ""target"":""~Foo|Bar""
  },
  {
    ""class"":""sifive.enterprise.firrtl.NestedPrefixModulesAnnotation"",
    ""prefix"":""prefix2_"",
    ""inclusive"":true,
    ""target"":""~Foo|Baz""
  }
]]
  module Bar:
  module Baz:
  module Foo:
    inst bar of Bar
    inst baz of Baz","module prefix2_Bar();
endmodule

module Foo();
  prefix2_Bar bar ();
  prefix2_Bar baz ();
endmodule","module prefix1_Bar();
endmodule

module prefix2_Baz();
endmodule

module Foo();
  prefix1_Bar bar ();
  prefix2_Baz baz ();
endmodule",,,,,,,
2531,"circuit Top : %[[
  {
    ""class"":""firrtl.transforms.DontTouchAnnotation"",
    ""target"":""Top.A.b""
  }
]]
  module Top :
    inst a1 of A
    inst a2 of A_
  module A :
    output x: UInt<1>
    wire b: UInt<1>
    b is invalid
    x <= b
  module A_ :
    output x: UInt<1>
    wire b: UInt<1>
    b is invalid
    x <= b","module  {
  firrtl.circuit ""Top""   {
    firrtl.module @Top() {
      %a1_x = firrtl.instance a1  @A(out x: !firrtl.uint<1>)
      %a2_x = firrtl.instance a2  @A_(out x: !firrtl.uint<1>)
    }
    firrtl.module @A(out %x: !firrtl.uint<1>) {
      %b = firrtl.wire sym @b  : !firrtl.uint<1>
      %invalid_ui1 = firrtl.invalidvalue : !firrtl.uint<1>
      firrtl.connect %b, %invalid_ui1 : !firrtl.uint<1>, !firrtl.uint<1>
      firrtl.connect %x, %b : !firrtl.uint<1>, !firrtl.uint<1>
    }
    firrtl.module @A_(out %x: !firrtl.uint<1>) {
      %b = firrtl.wire  : !firrtl.uint<1>
      %invalid_ui1 = firrtl.invalidvalue : !firrtl.uint<1>
      firrtl.connect %b, %invalid_ui1 : !firrtl.uint<1>, !firrtl.uint<1>
      firrtl.connect %x, %b : !firrtl.uint<1>, !firrtl.uint<1>
    }
  }
}","module  {
  firrtl.circuit ""Top""   {
    firrtl.module @Top() {
      %a1_x = firrtl.instance a1  @A(out x: !firrtl.uint<1>)
      %a2_x = firrtl.instance a2  @A(out x: !firrtl.uint<1>)
    }
    firrtl.module @A(out %x: !firrtl.uint<1>) {
      %invalid_ui1 = firrtl.invalidvalue : !firrtl.uint<1>
      %b = firrtl.wire sym @b  : !firrtl.uint<1>
      firrtl.connect %b, %invalid_ui1 {annotations = []} : !firrtl.uint<1>, !firrtl.uint<1>
      firrtl.connect %x, %b {annotations = []} : !firrtl.uint<1>, !firrtl.uint<1>
    }
  }
}","circuit Top :
  module A :
    output x : UInt<1>

    wire b : UInt<1> @[dont-touch.scala 33:15]
    b is invalid @[dont-touch.scala 34:5]
    x <= b @[dont-touch.scala 36:5]

  module Top :

    inst a1 of A @[dont-touch.scala 47:18]
    inst a2 of A @[dont-touch.scala 48:18]","[
  {
    ""class"":""firrtl.transforms.DontTouchAnnotation"",
    ""target"":""~Top|Top/a1:A>b""
  }
]",,,,,
2516,"; seed: 6243
circuit top_mod :
  module top_mod :
    input clock0: Clock
    input raddr: UInt<10>
    input waddr: UInt<10>
    input wdata: UInt<20>
    output tmp54: UInt<20>
    mem tmp53:
      data-type => UInt<20>
      depth => 10
      read-latency => 0
      write-latency => 1
      read-under-write => undefined
      reader => r0
      writer => w0
    tmp53.r0.clk <= clock0
    tmp53.r0.en <= UInt(0)
    tmp53.r0.addr <= waddr
    tmp53.w0.clk <= clock0
    tmp53.w0.en <= UInt(1)
    tmp53.w0.addr <= raddr
    tmp53.w0.data <= wdata
    tmp53.w0.mask <= UInt(1)
    tmp54 <= tmp53.r0.data","module tmp53_ext(	// a_top_mod.fir:9:5
  input  [3:0]  R0_addr,
  input         R0_en, R0_clk,
  input  [3:0]  W0_addr,
  input         W0_en, W0_clk,
  input  [19:0] W0_data,
  input         W0_mask,
  output [19:0] R0_data);

  reg [19:0] Memory[0:9];

  wire _T = W0_en & W0_mask;
  always @(posedge W0_clk) begin
    if (_T)
      Memory[W0_addr] <= W0_data;
  end // always @(posedge)
  assign R0_data = R0_en ? Memory[R0_addr] : 20'bx;	// a_top_mod.fir:9:5
endmodule

module top_mod(	// a_top_mod.fir:3:10
  input         clock0,
  input  [9:0]  raddr, waddr,
  input  [19:0] wdata,
  output [19:0] tmp54);

  tmp53_ext tmp53 (	// a_top_mod.fir:9:5
    .R0_addr (waddr[3:0]),	// a_top_mod.fir:19:19
    .R0_en   (1'h0),	// a_top_mod.fir:18:20
    .R0_clk  (clock0),
    .W0_addr (raddr[3:0]),	// a_top_mod.fir:22:19
    .W0_en   (1'h1),	// a_top_mod.fir:21:20
    .W0_clk  (clock0),
    .W0_data (wdata),
    .W0_mask (1'h1),	// a_top_mod.fir:21:20
    .R0_data (tmp54)
  );
endmodule","module top_mod(
  input         clock0,
  input  [9:0]  raddr,
  input  [9:0]  waddr,
  input  [19:0] wdata,
  output [19:0] tmp54
);
`ifdef RANDOMIZE_GARBAGE_ASSIGN
  reg [31:0] _RAND_1;
`endif // RANDOMIZE_GARBAGE_ASSIGN
`ifdef RANDOMIZE_MEM_INIT
  reg [31:0] _RAND_0;
`endif // RANDOMIZE_MEM_INIT
  reg [19:0] tmp53 [0:9];
  wire  tmp53_r0_en;
  wire [3:0] tmp53_r0_addr;
  wire [19:0] tmp53_r0_data;
  wire [19:0] tmp53_w0_data;
  wire [3:0] tmp53_w0_addr;
  wire  tmp53_w0_mask;
  wire  tmp53_w0_en;
  assign tmp53_r0_en = 1'h0;
  assign tmp53_r0_addr = waddr[3:0];
  `ifndef RANDOMIZE_GARBAGE_ASSIGN
  assign tmp53_r0_data = tmp53[tmp53_r0_addr];
  `else
  assign tmp53_r0_data = tmp53_r0_addr >= 4'ha ? _RAND_1[19:0] : tmp53[tmp53_r0_addr];
  `endif // RANDOMIZE_GARBAGE_ASSIGN
  assign tmp53_w0_data = wdata;
  assign tmp53_w0_addr = raddr[3:0];
  assign tmp53_w0_mask = 1'h1;
  assign tmp53_w0_en = 1'h1;
  assign tmp54 = tmp53_r0_data;
  always @(posedge clock0) begin
    if (tmp53_w0_en & tmp53_w0_mask) begin
      tmp53[tmp53_w0_addr] <= tmp53_w0_data;
    end
  end
// Register and memory initialization
`ifdef RANDOMIZE_GARBAGE_ASSIGN
`define RANDOMIZE
`endif
`ifdef RANDOMIZE_INVALID_ASSIGN
`define RANDOMIZE
`endif
`ifdef RANDOMIZE_REG_INIT
`define RANDOMIZE
`endif
`ifdef RANDOMIZE_MEM_INIT
`define RANDOMIZE
`endif
`ifndef RANDOM
`define RANDOM $random
`endif
`ifdef RANDOMIZE_MEM_INIT
  integer initvar;
`endif
`ifndef SYNTHESIS
`ifdef FIRRTL_BEFORE_INITIAL
`FIRRTL_BEFORE_INITIAL
`endif
initial begin
  `ifdef RANDOMIZE
    `ifdef INIT_RANDOM
      `INIT_RANDOM
    `endif
    `ifndef VERILATOR
      `ifdef RANDOMIZE_DELAY
        #`RANDOMIZE_DELAY begin end
      `else
        #0.002 begin end
      `endif
    `endif
`ifdef RANDOMIZE_GARBAGE_ASSIGN
  _RAND_1 = {1{`RANDOM}};
`endif // RANDOMIZE_GARBAGE_ASSIGN
`ifdef RANDOMIZE_MEM_INIT
  _RAND_0 = {1{`RANDOM}};
  for (initvar = 0; initvar < 10; initvar = initvar+1)
    tmp53[initvar] = _RAND_0[19:0];
`endif // RANDOMIZE_MEM_INIT
  `endif // RANDOMIZE
end // initial
`ifdef FIRRTL_AFTER_INITIAL
`FIRRTL_AFTER_INITIAL
`endif
`endif // SYNTHESIS
endmodule",ERROR: Found 20 unproven $equiv cells in 'equiv_status -assert'.,,,,,,
2504,"hw.module @top(%source: i1) -> (b: !hw.struct<zero: !hw.array<1xi0>, c: i1>) {
    %cast = hw.bitcast %source: (i1) -> !hw.struct<zero: !hw.array<1xi0>, c: i1>
    hw.output %cast : !hw.struct<zero: !hw.array<1xi0>, c: i1>
 }","module top(	// out.mlir:2:3
  input                                                            source,
  output struct packed {logic [0:0]/*Zero Width*/ zero; logic c; } b);
 
  assign b = source;	// out.mlir:3:12, :4:5
endmodule",,,,,,,,
2298,"module  {
  firrtl.circuit ""Foo""   {
    firrtl.module @Foo(in %a: !firrtl.uint<1>, out %b: !firrtl.uint<1>) {
      firrtl.connect %b, %a : !firrtl.uint<1>, !firrtl.uint<1>
    }
  }
  firrtl.circuit ""Bar""   {
    firrtl.module @Bar(in %a: !firrtl.uint<1>, out %b: !firrtl.uint<1>) {
      firrtl.connect %b, %a : !firrtl.uint<1>, !firrtl.uint<1>
    }
  }
}","module  {
  firrtl.circuit ""Bar""   {
    firrtl.module @Bar(in %a: !firrtl.uint<1>, out %b: !firrtl.uint<1>) {
      firrtl.connect %b, %a : !firrtl.uint<1>, !firrtl.uint<1>
    }
  }
  hw.module @Foo(%a: i1) -> (b: i1) {
    hw.output %a : i1
  }
}",,,,,,,,
2029,,,,,,,,,,
2026,,,,,,,,,,
1988,"llhd.entity @root () -> () {
  %time = llhd.constant_time #llhd.time<1ns, 0d, 0e>

  %hidden = hw.constant 0xff : i8
  %base = hw.constant 0 : i8
  %amnt = hw.constant 4 : i3

  %resultsig = llhd.sig ""result"" %base : i8
  %basesig = llhd.sig ""base"" %base : i8
  %hiddensig = llhd.sig ""hidden"" %hidden : i8
  %shr = llhd.shr %basesig, %hiddensig, %amnt : (!llhd.sig<i8>, !llhd.sig<i8>, i3) -> !llhd.sig<i8>
  %prbshr = llhd.prb %shr : !llhd.sig<i8>
  llhd.drv %resultsig, %prbshr after %time : !llhd.sig<i8>
}","0ps 0d 0e  root/base  0x00
0ps 0d 0e  root/hidden  0xff
0ps 0d 0e  root/result  0x00
1000ps 0d 0e  root/result  0xf0         // UB here (also seen 0x70, 0x10, etc.)
Finished at 2000ps 0d 0e (3 cycles)",,,,,,,,
1795,"llhd.entity @root () -> () {
    %0 = hw.constant 0 : i8
    %index = hw.constant 1 : i1

    %array = hw.array_create %0, %0 : i8
    %get = hw.array_get %array[%index] : !hw.array<2xi8>

    %getsig = llhd.sig ""get"" %get : i8  // Using %0 instead of %get works just fine; %get leads to a crash

    %time = llhd.constant_time #llhd.time<1ns, 0d, 0e>
    llhd.drv %getsig, %get after %time : !llhd.sig<i8>
}",,,,,,,,,
1771,"circuit Bar :
  module Bar :
    input a: UInt<1>
    output b: UInt<1024>

    b <= cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, a)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))","# lldb firtool -- Bar.fir
(lldb) target create ""firtool""
Current executable set to 'firtool' (x86_64).
(lldb) settings set -- target.run-args  ""Bar.fir""
(lldb) run
Process 10399 launched: '/Users/schuylere/usr/bin/firtool' (x86_64)
Process 10399 stopped
* thread #1, queue = 'com.apple.main-thread', stop reason = EXC_BAD_ACCESS (code=2, address=0x7ffeef3fffff)
    frame #0: 0x00000001005857e4 firtool`llvm::isAlpha(C=<unavailable>) at StringExtras.h:95
   92  	inline bool isHexDigit(char C) { return hexDigitValue(C) != ~0U; }
   93  	
   94  	/// Checks if character \p C is a valid letter as classified by ""C"" locale.
-> 95  	inline bool isAlpha(char C) {
   96  	  return ('a' <= C && C <= 'z') || ('A' <= C && C <= 'Z');
   97  	}
   98  	
Target 0: (firtool) stopped.
(lldb) frame select 1
frame #1: 0x000000010024a592 firtool`circt::firrtl::FIRLexer::lexIdentifierOrKeyword(this=0x00007ffeefbfdbe8, tokStart=""cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, a)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))""...) at FIRLexer.cpp:386:10
   383 	///
   384 	FIRToken FIRLexer::lexIdentifierOrKeyword(const char *tokStart) {
   385 	  // Match the rest of the identifier regex: [0-9a-zA-Z_$-]*
-> 386 	  while (llvm::isAlpha(*curPtr) || llvm::isDigit(*curPtr) || *curPtr == '_' ||
   387 	         *curPtr == '$' || *curPtr == '-')
   388 	    ++curPtr;
   389",,,,,,,,
1734,,,,,,,,,,
1289,"; seed: 1144
circuit top_mod :
  module top_mod :
    output _tmp40: UInt
    wire tmp19: UInt
    tmp19 <= mul(UInt(""o20575""), UInt<1>(0))
    _tmp40 <= dshl(UInt(""b10011010000001011101""), tail(tmp19, 15))","module top_mod(
  output [19:0] _tmp40);

  assign _tmp40 = 20'h9A05D;	// a_top_mod.fir:3:3, :7:20
endmodule","module top_mod(
  output [18:0] _tmp40
);
  assign _tmp40 = 19'h1a05d;
endmodule",ERROR: Can't match gold port `_tmp40_gold' to a gate port.,,,,,,
1065,"Failed Tests (210):
  CIRCT :: CAPI/ir.c
  CIRCT :: Conversion/FIRRTLToHW/errors.mlir
  CIRCT :: Conversion/FIRRTLToHW/lower-to-hw-errors.mlir
  CIRCT :: Conversion/FIRRTLToHW/lower-to-hw-module.mlir
  CIRCT :: Conversion/FIRRTLToHW/lower-to-hw.mlir
  CIRCT :: Conversion/FIRRTLToHW/zero-width.mlir
  CIRCT :: Conversion/FIRRTLToLLHD/connect.fir
  CIRCT :: Conversion/FIRRTLToLLHD/empty_inouts.fir
  CIRCT :: Conversion/FIRRTLToLLHD/empty_ins.fir
  CIRCT :: Conversion/FIRRTLToLLHD/empty_none.fir
  CIRCT :: Conversion/FIRRTLToLLHD/empty_outs.fir
  CIRCT :: Conversion/HWToLLHD/errors.mlir
  CIRCT :: Conversion/HWToLLHD/structure.mlir
  CIRCT :: Conversion/HandshakeToFIRRTL/simple_addi.mlir
  CIRCT :: Conversion/HandshakeToFIRRTL/test_branch.mlir
  CIRCT :: Conversion/HandshakeToFIRRTL/test_buffer.mlir
  CIRCT :: Conversion/HandshakeToFIRRTL/test_cmerge.mlir
  CIRCT :: Conversion/HandshakeToFIRRTL/test_conditional_branch.mlir
  CIRCT :: Conversion/HandshakeToFIRRTL/test_constant.mlir
  CIRCT :: Conversion/HandshakeToFIRRTL/test_fork.mlir
  CIRCT :: Conversion/HandshakeToFIRRTL/test_join.mlir
  CIRCT :: Conversion/HandshakeToFIRRTL/test_lazy_fork.mlir
  CIRCT :: Conversion/HandshakeToFIRRTL/test_load.mlir
  CIRCT :: Conversion/HandshakeToFIRRTL/test_memory.mlir
  CIRCT :: Conversion/HandshakeToFIRRTL/test_merge.mlir
  CIRCT :: Conversion/HandshakeToFIRRTL/test_mux.mlir
  CIRCT :: Conversion/HandshakeToFIRRTL/test_sink.mlir
  CIRCT :: Conversion/HandshakeToFIRRTL/test_store.mlir
  CIRCT :: Conversion/LLHDToLLVM/convert_arithmetic.mlir
  CIRCT :: Conversion/LLHDToLLVM/convert_bitwise.mlir
  CIRCT :: Conversion/LLHDToLLVM/convert_entity.mlir
  CIRCT :: Conversion/LLHDToLLVM/convert_extract.mlir
  CIRCT :: Conversion/LLHDToLLVM/convert_insert.mlir
  CIRCT :: Conversion/LLHDToLLVM/convert_memory.mlir
  CIRCT :: Conversion/LLHDToLLVM/convert_process_persistence.mlir
  CIRCT :: Conversion/LLHDToLLVM/convert_signals.mlir
  CIRCT :: Conversion/LLHDToLLVM/convert_simple.mlir
  CIRCT :: Conversion/LLHDToLLVM/convert_value_creation.mlir
  CIRCT :: Conversion/LLHDToLLVM/convert_wait.mlir
  CIRCT :: Conversion/StandardToHandshake/Affine/errors.mlir
  CIRCT :: Conversion/StandardToHandshake/Affine/test-affine-for.mlir
  CIRCT :: Conversion/StandardToHandshake/Affine/test-affine-load-store.mlir
  CIRCT :: Conversion/StandardToHandshake/test1.mlir
  CIRCT :: Conversion/StandardToHandshake/test10.mlir
  CIRCT :: Conversion/StandardToHandshake/test11.mlir
  CIRCT :: Conversion/StandardToHandshake/test12.mlir
  CIRCT :: Conversion/StandardToHandshake/test13.mlir
  CIRCT :: Conversion/StandardToHandshake/test14.mlir
  CIRCT :: Conversion/StandardToHandshake/test15.mlir
  CIRCT :: Conversion/StandardToHandshake/test16.mlir
  CIRCT :: Conversion/StandardToHandshake/test17.mlir
  CIRCT :: Conversion/StandardToHandshake/test18.mlir
  CIRCT :: Conversion/StandardToHandshake/test19.mlir
  CIRCT :: Conversion/StandardToHandshake/test2.mlir
  CIRCT :: Conversion/StandardToHandshake/test20.mlir
  CIRCT :: Conversion/StandardToHandshake/test21.mlir
  CIRCT :: Conversion/StandardToHandshake/test22.mlir
  CIRCT :: Conversion/StandardToHandshake/test23.mlir
  CIRCT :: Conversion/StandardToHandshake/test24.mlir
  CIRCT :: Conversion/StandardToHandshake/test25.mlir
  CIRCT :: Conversion/StandardToHandshake/test26.mlir
  CIRCT :: Conversion/StandardToHandshake/test27.mlir
  CIRCT :: Conversion/StandardToHandshake/test28.mlir
  CIRCT :: Conversion/StandardToHandshake/test29.mlir
  CIRCT :: Conversion/StandardToHandshake/test3.mlir
  CIRCT :: Conversion/StandardToHandshake/test30.mlir
  CIRCT :: Conversion/StandardToHandshake/test31.mlir
  CIRCT :: Conversion/StandardToHandshake/test32.mlir
  CIRCT :: Conversion/StandardToHandshake/test33.mlir
  CIRCT :: Conversion/StandardToHandshake/test34.mlir
  CIRCT :: Conversion/StandardToHandshake/test35.mlir
  CIRCT :: Conversion/StandardToHandshake/test4.mlir
  CIRCT :: Conversion/StandardToHandshake/test5.mlir
  CIRCT :: Conversion/StandardToHandshake/test6.mlir
  CIRCT :: Conversion/StandardToHandshake/test7.mlir
  CIRCT :: Conversion/StandardToHandshake/test8.mlir
  CIRCT :: Conversion/StandardToHandshake/test9.mlir
  CIRCT :: Conversion/StandardToHandshake/test_canonicalize.mlir
  CIRCT :: Conversion/StandardToHandshake/test_insert_buffer.mlir
  CIRCT :: Conversion/StandardToHandshake/test_insert_buffer_errors.mlir
  CIRCT :: Conversion/StandardToStaticLogic/test_pipeline.mlir
  CIRCT :: Dialect/ESI/connectivity.mlir
  CIRCT :: Dialect/ESI/errors.mlir
  CIRCT :: Dialect/ESI/lowering.mlir
  CIRCT :: Dialect/ESI/modwrap.mlir
  CIRCT :: Dialect/ESI/wrapif-lowering.mlir
  CIRCT :: Dialect/FIRRTL/annotations.fir
  CIRCT :: Dialect/FIRRTL/blackbox-memory.mlir
  CIRCT :: Dialect/FIRRTL/canonicalization.mlir
  CIRCT :: Dialect/FIRRTL/check-widths-errors.mlir
  CIRCT :: Dialect/FIRRTL/connect-errors.mlir
  CIRCT :: Dialect/FIRRTL/connect.mlir
  CIRCT :: Dialect/FIRRTL/const-prop-single-module.mlir
  CIRCT :: Dialect/FIRRTL/cse.mlir
  CIRCT :: Dialect/FIRRTL/errors.mlir
  CIRCT :: Dialect/FIRRTL/expand-whens-errors.mlir
  CIRCT :: Dialect/FIRRTL/expand-whens.mlir
  CIRCT :: Dialect/FIRRTL/imconstprop.mlir
  CIRCT :: Dialect/FIRRTL/infer-widths-errors.mlir
  CIRCT :: Dialect/FIRRTL/infer-widths.mlir
  CIRCT :: Dialect/FIRRTL/inliner.mlir
  CIRCT :: Dialect/FIRRTL/lower-types-errors.mlir
  CIRCT :: Dialect/FIRRTL/lower-types.mlir
  CIRCT :: Dialect/FIRRTL/parse-basic.fir
  CIRCT :: Dialect/FIRRTL/parse-errors.fir
  CIRCT :: Dialect/FIRRTL/parse-locations.fir
  CIRCT :: Dialect/FIRRTL/test.mlir
  CIRCT :: Dialect/HW/basic.mlir
  CIRCT :: Dialect/HW/bitwise.mlir
  CIRCT :: Dialect/HW/canonicalization.mlir
  CIRCT :: Dialect/HW/errors.mlir
  CIRCT :: Dialect/HW/greybox.mlir
  CIRCT :: Dialect/HW/modules.mlir
  CIRCT :: Dialect/HW/svEmitErrors.mlir
  CIRCT :: Dialect/HW/typedecls.mlir
  CIRCT :: Dialect/HW/types.mlir
  CIRCT :: Dialect/Handshake/errors.mlir
  CIRCT :: Dialect/LLHD/Canonicalization/arithmetic.mlir
  CIRCT :: Dialect/LLHD/Canonicalization/bitwise.mlir
  CIRCT :: Dialect/LLHD/Canonicalization/constant.mlir
  CIRCT :: Dialect/LLHD/Canonicalization/extract.mlir
  CIRCT :: Dialect/LLHD/Canonicalization/memory.mlir
  CIRCT :: Dialect/LLHD/Canonicalization/probeCSE.mlir
  CIRCT :: Dialect/LLHD/Canonicalization/signalOps.mlir
  CIRCT :: Dialect/LLHD/Export/verilog_arithmetic.mlir
  CIRCT :: Dialect/LLHD/Export/verilog_bitwise.mlir
  CIRCT :: Dialect/LLHD/Export/verilog_entity.mlir
  CIRCT :: Dialect/LLHD/Export/verilog_relations.mlir
  CIRCT :: Dialect/LLHD/Export/verilog_sig.mlir
  CIRCT :: Dialect/LLHD/Export/verilog_sig_errors.mlir
  CIRCT :: Dialect/LLHD/IR/arithmetic.mlir
  CIRCT :: Dialect/LLHD/IR/array.mlir
  CIRCT :: Dialect/LLHD/IR/bitwise.mlir
  CIRCT :: Dialect/LLHD/IR/connect-errors.mlir
  CIRCT :: Dialect/LLHD/IR/connect.mlir
  CIRCT :: Dialect/LLHD/IR/const.mlir
  CIRCT :: Dialect/LLHD/IR/entity.mlir
  CIRCT :: Dialect/LLHD/IR/extract-errors.mlir
  CIRCT :: Dialect/LLHD/IR/extract.mlir
  CIRCT :: Dialect/LLHD/IR/insert-errors.mlir
  CIRCT :: Dialect/LLHD/IR/insert.mlir
  CIRCT :: Dialect/LLHD/IR/inst-errors.mlir
  CIRCT :: Dialect/LLHD/IR/inst.mlir
  CIRCT :: Dialect/LLHD/IR/memory.mlir
  CIRCT :: Dialect/LLHD/IR/proc.mlir
  CIRCT :: Dialect/LLHD/IR/reg.mlir
  CIRCT :: Dialect/LLHD/IR/signal-errors.mlir
  CIRCT :: Dialect/LLHD/IR/signal.mlir
  CIRCT :: Dialect/LLHD/IR/time.mlir
  CIRCT :: Dialect/LLHD/IR/tuple.mlir
  CIRCT :: Dialect/LLHD/IR/wait.mlir
  CIRCT :: Dialect/LLHD/Simulator/sim_arbitrary_signal_size.mlir
  CIRCT :: Dialect/LLHD/Simulator/sim_array_boundary_check.mlir
  CIRCT :: Dialect/LLHD/Simulator/sim_bit_precision_drives.mlir
  CIRCT :: Dialect/LLHD/Simulator/sim_formats.mlir
  CIRCT :: Dialect/LLHD/Simulator/sim_process.mlir
  CIRCT :: Dialect/LLHD/Simulator/sim_reg.mlir
  CIRCT :: Dialect/LLHD/Simulator/sim_shifts.mlir
  CIRCT :: Dialect/LLHD/Simulator/sim_simple.mlir
  CIRCT :: Dialect/LLHD/Simulator/sim_wait.mlir
  CIRCT :: Dialect/LLHD/Transforms/earlyCodeMotion.mlir
  CIRCT :: Dialect/LLHD/Transforms/memoryToBlockArgument.mlir
  CIRCT :: Dialect/LLHD/Transforms/processLowering.mlir
  CIRCT :: Dialect/LLHD/Transforms/processLoweringErrors.mlir
  CIRCT :: Dialect/LLHD/Transforms/totalFunctionInlining.mlir
  CIRCT :: Dialect/MSFT/location.mlir
  CIRCT :: Dialect/MSFT/opt-errors.mlir
  CIRCT :: Dialect/MSFT/translate-errors.mlir
  CIRCT :: Dialect/SV/basic.mlir
  CIRCT :: Dialect/SV/canonicalization.mlir
  CIRCT :: Dialect/SV/errors.mlir
  CIRCT :: Dialect/SV/hw-cleanup.mlir
  CIRCT :: Dialect/SV/hw-generator-callout.mlir
  CIRCT :: Dialect/SV/hw-legalize-names-errors.mlir
  CIRCT :: Dialect/SV/hw-legalize-names.mlir
  CIRCT :: Dialect/SV/hw-memsim.mlir
  CIRCT :: Dialect/SV/interfaces.mlir
  CIRCT :: Dialect/SV/prettify-verilog.mlir
  CIRCT :: Dialect/Seq/basic.mlir
  CIRCT :: ExportVerilog/hw-dialect.mlir
  CIRCT :: ExportVerilog/hw-typedecls.mlir
  CIRCT :: ExportVerilog/line-length.mlir
  CIRCT :: ExportVerilog/load-dialect.mlir
  CIRCT :: ExportVerilog/sv-alwaysff.mlir
  CIRCT :: ExportVerilog/sv-dialect.mlir
  CIRCT :: ExportVerilog/sv-interfaces.mlir
  CIRCT :: ExportVerilog/verilog-basic.mlir
  CIRCT :: ExportVerilog/verilog-errors.mlir
  CIRCT :: circt-opt/trivial.mlir
  CIRCT :: circt-translate/parse_int64.fir
  CIRCT :: firtool/firtool.fir
  CIRCT :: firtool/firtool.mlir
  CIRCT :: firtool/optimizations.fir
  CIRCT :: firtool/phase-ordering.fir
  CIRCT :: firtool/split-verilog.mlir
  CIRCT :: firtool/style.fir
  CIRCT :: handshake-runner/call_bb.mlir
  CIRCT :: handshake-runner/cdiv-old-std.mlir
  CIRCT :: handshake-runner/cdiv-std.mlir
  CIRCT :: handshake-runner/complex_bb.mlir
  CIRCT :: handshake-runner/floydwarshall-std.mlir
  CIRCT :: handshake-runner/histogram-std.mlir
  CIRCT :: handshake-runner/loadstore.mlir
  CIRCT :: handshake-runner/loop-check-1-std.mlir
  CIRCT :: handshake-runner/loop-check-2-std.mlir
  CIRCT :: handshake-runner/matmul-check-std.mlir
  CIRCT :: handshake-runner/matmul-std.mlir
  CIRCT :: handshake-runner/memory_simple_2_std.mlir
  CIRCT :: handshake-runner/memory_simple_std.mlir
  CIRCT :: handshake-runner/simple_loop.mlir


Testing Time: 1.34s
  Unsupported:   4
  Passed     :   6
  Failed     : 210",,,,,,,,,
907,"circuit Instance:
  module Sub:
    output a: UInt<1>
    a <= UInt<1>(0)

  module Instance:
    output a: {a: UInt<1>}

    inst sub of Sub
    a <= sub
    a <- sub","# circt-translate --import-firrtl new/Instance.fir
new/Instance.fir:11:5: error: expected '.' in field reference
    a <- sub
    ^",,,,,,,,
806,"llhd.entity @adder(%clk: !llhd.sig, %res: !llhd.sig)  (%i5_output: !llhd.sig ) {
%0 = llhd.const #llhd.time<0s, 0d, 1e> : !llhd.time
%1 = llhd.const 16 : i32
llhd.drv %i5_output, %1 after %0 : !llhd.sig
}","Assertion failed: (idx < size()), function operator[], file /llvm/llvm/include/llvm/ADT/SmallVector.h, line 277.
PLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.
Stack dump:
0. Program arguments: /build/bin/llhd-sim addersvllhd.mlir -n 10 -r adder
Stack dump without symbol names (ensure you have llvm-symbolizer in your PATH or set the environment var LLVM_SYMBOLIZER_PATH to point to it):
0 libcirct-llhd-signals-runtime-wrappers.dylib 0x000000011dca593d llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) + 61
1 libcirct-llhd-signals-runtime-wrappers.dylib 0x000000011dca5eeb PrintStackTraceSignalHandler(void*) + 27
2 libcirct-llhd-signals-runtime-wrappers.dylib 0x000000011dca3a6b llvm::sys::RunSignalHandlers() + 123
3 libcirct-llhd-signals-runtime-wrappers.dylib 0x000000011dca83f8 SignalHandler(int) + 232
4 libsystem_platform.dylib 0x00007fff6af445fd _sigtramp + 29
5 libdyld.dylib 0x00007fff6ad4a78f dyldGlobalLockRelease() + 0
6 libsystem_c.dylib 0x00007fff6ae1a808 abort + 120
7 libsystem_c.dylib 0x00007fff6ae19ac6 err + 0
8 libcirct-llhd-signals-runtime-wrappers.dylib 0x000000011db4fa48 llvm::SmallVectorTemplateCommon<circt::llhd::sim::Signal, void>::operator[](unsigned long) + 104
9 libcirct-llhd-signals-runtime-wrappers.dylib 0x000000011db4f912 driveSignal + 178
10 libcirct-llhd-signals-runtime-wrappers.dylib 0x000000011e1240f1 driveSignal + 6113425
11 llhd-sim 0x000000010acda78e main + 1518
12 libdyld.dylib 0x00007fff6ad4bcc9 start + 1",,,,,,,,
787,,,,,,,,,,
